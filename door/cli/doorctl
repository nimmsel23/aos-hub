#!/usr/bin/env bash
# doorctl - Door Task Management CLI
# Sources logic from door/lib/* for reusability

set -euo pipefail

DOORCTL_VERSION="2.0.0"

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
DOOR_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
ROOT_DIR="$(cd "$DOOR_DIR/.." && pwd)"

# Codex session helper
# shellcheck disable=SC1091
source "$ROOT_DIR/scripts/lib/codex-subcmd.sh"
codex_subcmd_maybe "door" "doorctl" "$@" && exit 0

# Load global env
# shellcheck disable=SC1091
source "$ROOT_DIR/scripts/lib/aos-env.sh"
aos_env_load "" "$ROOT_DIR" || true

# Load UI helpers
# shellcheck disable=SC1091
source "$ROOT_DIR/scripts/ctl-lib.sh"

# Load door libs
# shellcheck disable=SC1091
source "$DOOR_DIR/lib/door_data.sh"
# shellcheck disable=SC1091
source "$DOOR_DIR/lib/door_phase.sh"
# shellcheck disable=SC1091
source "$DOOR_DIR/lib/door_health.sh"
# shellcheck disable=SC1091
source "$DOOR_DIR/lib/door_format.sh"

# Config
VAULT_DIR="${AOS_VAULT_DIR:-$HOME/AlphaOS-Vault}"
STALLED_DAYS="${AOS_DOOR_STALLED_DAYS:-7}"
TASK_BIN="${TASK_BIN:-task}"

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Commands
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_list() {
  ui_title "Active Doors"

  local doors
  doors=$(get_doors)

  if [[ "$doors" == "[]" || -z "$doors" ]]; then
    ui_info "No doors found. Create your first door with: doorctl create"
    return 0
  fi

  # Draw table
  draw_table_header

  # Parse and display each door
  echo "$doors" | jq -r '.[] | @json' | while IFS= read -r door; do
    format_door_row "$door"
  done

  draw_table_footer
  echo
  ui_info "Symbols: ğŸ’¡ Potential | ğŸ“‹ Plan | ğŸ”¨ Production | ğŸ’° Profit"
  ui_info "Alerts: âš ï¸  Needs attention (3+ days) | ğŸ”¥ Stalled ($STALLED_DAYS+ days)"
}

cmd_show() {
  local door_name="$1"
  [[ -z "$door_name" ]] && { ui_err "Usage: doorctl show <door-name>"; exit 1; }

  ui_title "Door: $door_name"

  local tasks
  tasks=$(get_door_tasks "$door_name")

  if [[ "$tasks" == "[]" || -z "$tasks" ]]; then
    ui_err "Door not found: $door_name"
    return 1
  fi

  # Door metadata
  local meta
  meta=$(get_door_metadata "$door_name")

  local count
  count=$(echo "$meta" | jq -r '.count')
  local done
  done=$(echo "$meta" | jq -r '.done')
  local pending
  pending=$(echo "$meta" | jq -r '.pending')
  local project
  project=$(echo "$meta" | jq -r '.project // "N/A"')
  local tags
  tags=$(echo "$meta" | jq -r '.tags | join(", ")')
  local phase
  phase=$(get_door_phase "$(echo "$meta" | jq -r '.tags')")

  echo "Phase: $(format_phase "$phase")"
  echo "Project: $project"
  echo "Tags: $tags"
  echo "Hits: $count total, $done done, $pending pending"
  echo

  # Progress bar
  if ((count > 0)); then
    local pct=$((done * 100 / count))
    printf "Progress: ["
    draw_progress_bar "$done" "$count" 20
    printf "] %d%%\n\n" "$pct"
  fi

  # Task lists
  ui_info "Pending Hits:"
  echo "$tasks" | jq -r '.[] | select(.status == "pending") | @json' | while IFS= read -r task; do
    format_task_item "$task" "ğŸ”²"
  done

  echo
  ui_info "Completed Hits:"
  echo "$tasks" | jq -r '.[] | select(.status == "completed") | @json' | while IFS= read -r task; do
    format_task_item "$task" "âœ…"
  done
}

cmd_hits() {
  local door_name="${1:-}"
  local status_filter="${2:-pending}"

  if [[ -z "$door_name" ]]; then
    # Show all hits across all doors
    ui_title "All Hits"
    "$TASK_BIN" +hit status:"$status_filter"
    return
  fi

  ui_title "Hits for: $door_name"

  local tasks
  tasks=$(get_door_tasks "$door_name")

  if [[ "$tasks" == "[]" || -z "$tasks" ]]; then
    ui_err "No hits found for door: $door_name"
    return 1
  fi

  echo "$tasks" | jq -r --arg status "$status_filter" '.[] | select(.status == $status) | @json' | while IFS= read -r task; do
    format_task_item "$task" "ğŸ”²"
  done
}

cmd_next() {
  local door_name="${1:-}"

  ui_title "Next Hit"

  if [[ -n "$door_name" ]]; then
    # Next hit for specific door
    "$TASK_BIN" next door_name:"$door_name" limit:1 2>/dev/null
  else
    # Next hit across all doors
    "$TASK_BIN" next +door limit:3 2>/dev/null
  fi
}

cmd_done() {
  local uuid_prefix="$1"
  [[ -z "$uuid_prefix" ]] && { ui_err "Usage: doorctl done <uuid-prefix>"; exit 1; }

  mark_hit_done "$uuid_prefix"
  ui_ok "Hit marked done: $uuid_prefix"
}

cmd_hitlist() {
  ui_title "Hit List (All Pending Hits)"
  "$TASK_BIN" +hit status:pending
}

cmd_health() {
  ui_title "Door Health Check"

  local doors
  doors=$(get_doors)

  if [[ "$doors" == "[]" || -z "$doors" ]]; then
    ui_info "No doors to check."
    return 0
  fi

  echo "$doors" | jq -r '.[] | @json' | while IFS= read -r door; do
    local name
    name=$(echo "$door" | jq -r '.name')
    local modified
    modified=$(echo "$door" | jq -r '.modified')
    local activity
    activity=$(time_ago "$modified")

    local health_status
    health_status=$(get_health_status "$modified")
    local emoji
    emoji=$(get_health_emoji "$health_status")

    case "$health_status" in
      stalled) ui_err "$emoji $name: STALLED ($activity)" ;;
      attention) ui_warn "$emoji $name: Needs attention ($activity)" ;;
      healthy) ui_ok "$emoji $name: Healthy ($activity)" ;;
    esac
  done

  echo
  ui_info "Stalled = no activity in $STALLED_DAYS+ days"
  ui_info "Needs attention = no activity in 3+ days"
}

cmd_stalled() {
  ui_title "Stalled Doors"

  local doors
  doors=$(get_doors)

  if [[ "$doors" == "[]" || -z "$doors" ]]; then
    ui_info "No doors found."
    return 0
  fi

  local found=0
  echo "$doors" | jq -r '.[] | @json' | while IFS= read -r door; do
    local name
    name=$(echo "$door" | jq -r '.name')
    local modified
    modified=$(echo "$door" | jq -r '.modified')
    local activity
    activity=$(time_ago "$modified")

    if is_stalled "$modified"; then
      echo "- $name ($activity)"
      found=1
    fi
  done

  if ((found == 0)); then
    ui_ok "No stalled doors!"
  fi
}

cmd_focus() {
  ui_title "Today's Focus (Top 3 Hits)"
  "$TASK_BIN" +door +hit status:pending limit:3
}

cmd_edit() {
  local uuid_prefix="$1"
  [[ -z "$uuid_prefix" ]] && { ui_err "Usage: doorctl edit <uuid-prefix>"; exit 1; }

  # Detect best available editor
  local editor="${EDITOR:-nano}"
  if command -v micro >/dev/null 2>&1; then
    editor=micro
  elif command -v nano >/dev/null 2>&1; then
    editor=nano
  fi

  # Use task edit (interactive)
  "$TASK_BIN" "$uuid_prefix" edit

  ui_ok "Task edited: $uuid_prefix"
}

cmd_open() {
  local uuid_prefix="$1"
  [[ -z "$uuid_prefix" ]] && { ui_err "Usage: doorctl open <uuid-prefix>"; exit 1; }

  if ! command -v taskopen >/dev/null 2>&1; then
    ui_err "taskopen not installed. Install: yay -S taskopen"
    return 1
  fi

  taskopen "$uuid_prefix"
}

cmd_war() {
  local door_name="$1"
  local action="${2:-show}"

  [[ -z "$door_name" ]] && { ui_err "Usage: doorctl war <door-name> [show|edit]"; exit 1; }

  local warstack_file="$VAULT_DIR/Door/War-Stacks/${door_name}.md"

  case "$action" in
    show|view)
      if [[ ! -f "$warstack_file" ]]; then
        ui_err "War Stack not found: $warstack_file"
        ui_info "Create one first with warstack bot or Index Node"
        return 1
      fi

      # Use glow for pretty rendering if available
      if command -v glow >/dev/null 2>&1; then
        glow -p "$warstack_file"
      elif command -v bat >/dev/null 2>&1; then
        bat --style=plain "$warstack_file"
      else
        cat "$warstack_file"
      fi
      ;;

    edit)
      local editor="${EDITOR:-nano}"

      # Detect best editor
      if command -v micro >/dev/null 2>&1; then
        editor=micro
      elif command -v nano >/dev/null 2>&1; then
        editor=nano
      fi

      # Create if doesn't exist
      if [[ ! -f "$warstack_file" ]]; then
        mkdir -p "$(dirname "$warstack_file")"
        cat > "$warstack_file" <<'EOF'
# War Stack: DOOR_NAME

## FACT
What is the objective reality?

## OBSTACLE
What's in the way?

## STRIKE
What decisive action will overcome the obstacle?

## RESPONSIBILITY
What is my commitment?

---

## 4 Hits

1. [ ] Hit 1
2. [ ] Hit 2
3. [ ] Hit 3
4. [ ] Hit 4
EOF
        sed -i "s/DOOR_NAME/$door_name/" "$warstack_file"
        ui_info "Created template: $warstack_file"
      fi

      $editor "$warstack_file"
      ui_ok "War Stack edited: $door_name"
      ;;

    *)
      ui_err "Unknown action: $action (use show|edit)"
      return 1
      ;;
  esac
}

cmd_note() {
  local door_name="$1"
  [[ -z "$door_name" ]] && { ui_err "Usage: doorctl note <door-name>"; exit 1; }

  local note_file="$VAULT_DIR/Door/notes/${door_name}.md"
  local editor="${EDITOR:-nano}"

  # Detect best editor
  if command -v micro >/dev/null 2>&1; then
    editor=micro
  elif command -v nano >/dev/null 2>&1; then
    editor=nano
  fi

  # Create if doesn't exist
  if [[ ! -f "$note_file" ]]; then
    mkdir -p "$(dirname "$note_file")"
    cat > "$note_file" <<EOF
# Notes: $door_name

Date: $(date +%Y-%m-%d)

## Ideas

## Blockers

## Next Steps
EOF
    ui_info "Created note: $note_file"
  fi

  $editor "$note_file"
  ui_ok "Note saved: $door_name"
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Help & Main
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

show_help() {
  cat <<'EOF'
doorctl v2.0 - Door Task Management System

Usage:
  doorctl <command> [args...]

Commands:
  list                    List all active doors with status
  show <door>             Show detail view for specific door
  hits [door] [status]    List hits for door (default: pending)
  next [door]             Show next hit to work on
  done <uuid>             Mark hit as completed
  edit <uuid>             Edit hit in editor (nano/micro/$EDITOR)
  open <uuid>             Open hit with taskopen
  hitlist                 Show all pending hits across all doors
  focus                   Show today's focus (top 3 hits)
  health                  Check door health (stalled, needs attention)
  stalled                 List stalled doors only
  war <door> [show|edit]  View/edit war stack (with glow/bat/cat)
  note <door>             Edit door notes

  version                 Show version
  help                    Show this help

Examples:
  doorctl list
  doorctl show Ausbildung
  doorctl hits Ausbildung
  doorctl next
  doorctl done 123abc
  doorctl edit 123abc
  doorctl open 123abc
  doorctl war Ausbildung
  doorctl war Ausbildung edit
  doorctl note Ausbildung
  doorctl health

Config (env vars):
  AOS_VAULT_DIR           Vault location (default: ~/AlphaOS-Vault)
  AOS_DOOR_STALLED_DAYS   Days before door is stalled (default: 7)
  TASK_BIN                Taskwarrior binary (default: task)
  EDITOR                  Preferred editor (default: nano)

Optional tools:
  micro                   Modern terminal editor (preferred)
  nano                    Simple editor (fallback)
  taskopen                Open tasks with external tools
  glow                    Beautiful markdown rendering
  bat                     Pretty file viewer

Notes:
  - Requires Taskwarrior with door_name UDA
  - Tasks must have +door or +hit tags
  - Uses task export for data
  - Logic in: door/lib/*.sh (reusable by Index Node)
EOF
}

main() {
  local cmd="${1:-help}"
  shift || true

  case "$cmd" in
    list|ls) cmd_list ;;
    show) cmd_show "$@" ;;
    hits) cmd_hits "$@" ;;
    next) cmd_next "$@" ;;
    done) cmd_done "$@" ;;
    edit) cmd_edit "$@" ;;
    open) cmd_open "$@" ;;
    hitlist|all) cmd_hitlist ;;
    focus|today) cmd_focus ;;
    health) cmd_health ;;
    stalled) cmd_stalled ;;
    war) cmd_war "$@" ;;
    note|notes) cmd_note "$@" ;;
    version) echo "doorctl v$DOORCTL_VERSION" ;;
    help|-h|--help) show_help ;;
    *)
      ui_err "Unknown command: $cmd"
      show_help
      exit 2
      ;;
  esac
}

main "$@"
