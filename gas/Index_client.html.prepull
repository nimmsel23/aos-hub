<script>
    let MAP_URLS = window.MAP_URLS || {};
    const INLINE_SECTIONS = {
      maps: 'mapsCentre',
      fruits: 'fruitsCentre',
      game: 'mapsCentre'
    };
    const INLINE_MAP_KEYS = ['door', 'voice', 'frame', 'freedom', 'focus', 'fire', 'tent'];
    const INLINE_ALIASES = {
      door_centre: 'door',
      doorcenter: 'door',
      doorcentre: 'door'
    };
    const INLINE_TEMPLATES = {
      door: 'map-template-door',
      voice: 'map-template-voice',
      frame: 'map-template-frame',
      freedom: 'map-template-freedom',
      focus: 'map-template-focus',
      fire: 'map-template-fire',
      tent: 'map-template-tent'
    };
    const MATRIX_ITEMS = [
      { label: 'MAPS Centre', type: 'inline', key: 'maps' },
      { label: 'Door Centre', type: 'map', key: 'door' },
      { label: 'The Voice', type: 'map', key: 'voice' },
      { label: 'Frame Map', type: 'map', key: 'frame' },
      { label: 'Freedom Map', type: 'map', key: 'freedom' },
      { label: 'Focus Map', type: 'map', key: 'focus' },
      { label: 'Fire Map', type: 'map', key: 'fire' },
      { label: "General's Tent", type: 'map', key: 'tent' },
      { label: 'Fruits Centre', type: 'inline', key: 'fruits' },
      { label: 'Body GPT', type: 'link', key: 'body' },
      { label: 'Being GPT', type: 'link', key: 'being' },
      { label: 'Balance GPT', type: 'link', key: 'balance' },
      { label: 'Business GPT', type: 'link', key: 'business' }
    ];
    const CENTRE_DOTS = [
      { label: 'Door Centre', type: 'link', key: 'door_centre' },
      { label: 'Door', type: 'link', key: 'door' },
      { label: 'Voice', type: 'link', key: 'voice' },
      { label: 'Game', type: 'link', key: 'game' },
      { label: 'Frame', type: 'link', key: 'frame' },
      { label: 'Freedom', type: 'link', key: 'freedom' },
      { label: 'Focus', type: 'link', key: 'focus' },
      { label: 'Fire', type: 'link', key: 'fire' },
      { label: 'Tent', type: 'link', key: 'tent' },
      { label: 'Fruits', type: 'link', key: 'fruits' },
      { label: 'Creator King', type: 'link', key: 'creator' },
      { label: 'AllMyLinks', type: 'link', key: 'allmylinks' },
      { label: 'WordPress', type: 'link', key: 'wordpress' },
      { label: 'Fadaro', type: 'link', key: 'fadaro' }
    ];

    function toggleSection(id) {
      const sections = document.querySelectorAll('.extra-section');
      const target = document.getElementById(id);
      if (!target) return;
      const willShow = target.classList.contains('hidden');
      sections.forEach(sec => sec.classList.add('hidden'));
      if (id !== 'mapsCentre') {
        hideInlineMap();
      }
      if (willShow) {
        target.classList.remove('hidden');
        target.scrollIntoView({ behavior: 'smooth' });
        hideHomeShell();
        hideHeader();
      } else {
        showHomeShell();
        showHeader();
      }
    }

    function setMapUrls(urls) {
      MAP_URLS = (urls && typeof urls === 'object') ? urls : {};
      window.MAP_URLS = MAP_URLS;
    }

    function normalizeKey(key) {
      return String(key || '').toLowerCase().trim();
    }

    function resolveInlineKey(key) {
      const normalized = normalizeKey(key);
      if (INLINE_MAP_KEYS.includes(normalized)) return normalized;
      if (INLINE_ALIASES[normalized]) return INLINE_ALIASES[normalized];
      return '';
    }

    function setActiveMap(key) {
      window.AOS_ACTIVE_MAP = key || '';
    }

    function stripDoctype(html) {
      return String(html || '').replace(/<!doctype[^>]*>/i, '').trim();
    }

    function activateScripts(root) {
      const scripts = Array.from(root.querySelectorAll('script'));
      scripts.forEach(script => {
        if (script.src) {
          script.remove();
          return;
        }
        const next = document.createElement('script');
        if (script.type) next.type = script.type;
        next.text = script.textContent;
        script.replaceWith(next);
      });
    }

    function renderInlineMap(key) {
      const body = document.getElementById('mapsInlineBody');
      if (!body) return false;
      body.innerHTML = '';

      const tplId = INLINE_TEMPLATES[key];
      const tpl = tplId ? document.getElementById(tplId) : null;
      if (!tpl) return false;

      const raw = stripDoctype(tpl.innerHTML || '');
      const wrapper = document.createElement('div');
      wrapper.innerHTML = raw;

      const head = wrapper.querySelector('head');
      const content = wrapper.querySelector('body');
      const fragment = document.createDocumentFragment();

      if (head) {
        Array.from(head.children).forEach(node => fragment.appendChild(node));
      }
      if (content) {
        Array.from(content.children).forEach(node => fragment.appendChild(node));
      }
      if (!head && !content) {
        Array.from(wrapper.childNodes).forEach(node => fragment.appendChild(node));
      }

      body.appendChild(fragment);
      activateScripts(body);
      return true;
    }

    function showInlineMap(label, key) {
      const inline = document.getElementById('mapsInline');
      const title = document.getElementById('mapsInlineTitle');
      const sub = document.getElementById('mapsInlineSub');
      const mapsSection = document.getElementById('mapsCentre');
      if (!inline) return;

      if (mapsSection && mapsSection.classList.contains('hidden')) {
        document.querySelectorAll('.extra-section').forEach(sec => sec.classList.add('hidden'));
        mapsSection.classList.remove('hidden');
      }

      if (title) title.textContent = label || 'Map View';
      if (sub) sub.textContent = 'Inline';
      if (!renderInlineMap(key)) {
        alert('Missing inline map: ' + key);
        return;
      }
      inline.classList.remove('hidden');
      hideHomeShell();
      hideHeader();
      setActiveMap(key);

      inline.scrollIntoView({ behavior: 'smooth' });
    }

    function hideInlineMap() {
      const inline = document.getElementById('mapsInline');
      const body = document.getElementById('mapsInlineBody');
      if (inline) inline.classList.add('hidden');
      if (body) body.innerHTML = '';
      document.body.classList.forEach(cls => {
        if (cls.startsWith('theme-')) {
          document.body.classList.remove(cls);
        }
      });
      setActiveMap('');
      showHomeShell();
      showHeader();
    }

    function setStatus(id, state, label) {
      const el = document.getElementById(id);
      if (!el) return;
      const text = label || 'Unknown';
      if (state === true) {
        el.className = 'text-green-400';
        el.textContent = `‚óè  ${text}`;
        return;
      }
      if (state === false) {
        el.className = 'text-red-400';
        el.textContent = `‚óè  ${text}`;
        return;
      }
      el.className = 'text-yellow-400';
      el.textContent = `‚óè  ${text}`;
    }

    function formatStatusLine(item) {
      if (!item) return 'Unknown';
      const label = item.label || 'Unknown';
      if (item.ok === true) {
        return `OK ${label}${item.url ? ' @ ' + item.url : ''}`;
      }
      if (item.ok === false) {
        return `FAIL ${label}${item.url ? ' @ ' + item.url : ''}`;
      }
      return label;
    }

    function hideHomeShell() {
      const shell = document.getElementById('homeShell');
      if (shell) {
        shell.classList.add('hidden');
        shell.style.display = 'none';
      }
      const tb = document.getElementById('centreToolbar');
      if (tb) {
        tb.classList.remove('hidden');
        tb.style.display = 'flex';
      }
    }

    function showHomeShell() {
      const shell = document.getElementById('homeShell');
      if (shell) {
        shell.classList.remove('hidden');
        shell.style.display = '';
      }
      const tb = document.getElementById('centreToolbar');
      if (tb) {
        tb.classList.add('hidden');
        tb.style.display = 'none';
      }
    }

    function hideHeader() {
      const h = document.getElementById('mainHeader');
      if (h) {
        h.classList.add('hidden');
        h.style.display = 'none';
      }
    }

    function showHeader() {
      const h = document.getElementById('mainHeader');
      if (h) {
        h.classList.remove('hidden');
        h.style.display = '';
      }
    }

    function loadSystemStatus() {
      setStatus('gas-status', true, 'Online');
      if (!(window.google && google.script && google.script.run)) {
        setStatus('bridge-status', null, 'Unknown');
        setStatus('router-status', null, 'Unknown');
        setStatus('heartbeat-status', null, 'Unknown');
        addToTerminal('systemstatus', 'google.script not available');
        return;
      }

      if (!window.AOS_SESSION_ID) {
        const stamp = Date.now().toString(36);
        const rand = Math.random().toString(36).slice(2, 8);
        window.AOS_SESSION_ID = `${stamp}-${rand}`;
      }

      google.script.run
        .withSuccessHandler(data => {
          console.log('SystemStatus data:', data);
          const bridge = data && data.bridge;
          const router = data && data.router;
          const heartbeat = data && data.heartbeat;
          const server = data && data.server;
          setStatus('bridge-status', bridge && bridge.ok, bridge && bridge.label ? bridge.label : 'Unknown');
          setStatus('router-status', router && router.ok, router && router.label ? router.label : 'Unknown');
          setStatus('heartbeat-status', heartbeat && heartbeat.ok, heartbeat && heartbeat.label ? heartbeat.label : 'Unknown');
          const serverEl = document.getElementById('server-time');
          if (serverEl) {
            serverEl.textContent = server && server.locale ? server.locale : '‚Äî';
          }
          const lines = [
            `GAS: Online`,
            `Bridge: ${formatStatusLine(bridge)}`,
            `Router: ${formatStatusLine(router)}`,
            `Heartbeat: ${formatStatusLine(heartbeat)}`,
            `Server: ${server && server.locale ? server.locale : '‚Äî'}`
          ];
          addToTerminal('systemstatus', lines.join('\n'));
        })
        .withFailureHandler(err => {
          console.warn('SystemStatus: getSystemStatus_ failed');
          setStatus('bridge-status', false, 'Offline');
          setStatus('router-status', false, 'Offline');
          setStatus('heartbeat-status', false, 'Offline');
          addToTerminal('systemstatus', 'status failed: ' + err);
        })
        .getSystemStatus_({ sessionId: window.AOS_SESSION_ID });
    }

    function loadDashboardStats() {
      if (!(window.google && google.script && google.script.run)) return;
      google.script.run
        .withSuccessHandler(stats => {
          const nextStats = {
            hotlist: (stats && stats.hotlist != null) ? stats.hotlist : 0,
            warstacks: (stats && stats.warstacks != null) ? stats.warstacks : 0,
            hits: (stats && stats.hits != null) ? stats.hits : 0
          };
          window.AOS_STATS = nextStats;
          const hotEl = document.getElementById('hot-list-count');
          const warEl = document.getElementById('war-stacks-count');
          const hitEl = document.getElementById('hits-count');
          if (hotEl) hotEl.textContent = String(nextStats.hotlist);
          if (warEl) warEl.textContent = String(nextStats.warstacks);
          if (hitEl) hitEl.textContent = String(nextStats.hits);
        })
        .withFailureHandler(() => {})
        .getDashboardStats_();
    }

    function hydrateMapUrls(done) {
      const hasUrls = Object.keys(MAP_URLS).some(key => MAP_URLS[key]);
      if (hasUrls || !(window.google && google.script && google.script.run)) {
        if (done) done();
        return;
      }
      google.script.run
        .withSuccessHandler(urls => {
          setMapUrls(urls || {});
          if (done) done();
        })
        .withFailureHandler(() => {
          if (done) done();
        })
        .getCentreUrls_();
    }

    function openMap(label, key, options) {
      const forceLink = options && options.forceLink;
      const normalized = normalizeKey(key);
      const inlineKey = resolveInlineKey(normalized);
      if (!forceLink && INLINE_SECTIONS[normalized]) {
        toggleSection(INLINE_SECTIONS[normalized]);
        return;
      }
      if (!forceLink && inlineKey) {
        showInlineMap(label, inlineKey);
        return;
      }
      const overlay = document.getElementById('maps-overlay');
      const titleEl = document.getElementById('maps-loading-title');
      if (titleEl) titleEl.textContent = label;
      if (overlay) overlay.classList.add('active');

      const url = MAP_URLS[normalized] || '';
      setTimeout(() => {
        if (!url) {
          alert('Missing URL for: ' + normalized);
          if (overlay) overlay.classList.remove('active');
          return;
        }
        const useTelegram = (typeof isTelegramWebApp === 'function') && isTelegramWebApp();
        if (useTelegram && typeof window.Telegram.WebApp.openLink === 'function') window.Telegram.WebApp.openLink(url);
        else window.open(url, '_blank');
        if (overlay) setTimeout(() => overlay.classList.remove('active'), 600);
      }, 450);
    }

    function buildCentreDots() {
      const wrap = document.getElementById('centreDots');
      if (!wrap) return;
      wrap.innerHTML = '';
      CENTRE_DOTS.forEach(item => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'centre-dot-btn';
        btn.title = item.label;
        btn.setAttribute('aria-label', item.label);
        const dot = document.createElement('span');
        dot.className = 'centre-dot';
        btn.appendChild(dot);
        btn.addEventListener('click', () => {
          if (MAP_URLS[item.key]) {
            openMap(item.label, item.key, { forceLink: true });
            return;
          }
          if (INLINE_MAP_KEYS.includes(item.key)) {
            showInlineMap(item.label, item.key);
            return;
          }
          if (INLINE_SECTIONS[item.key]) {
            toggleSection(INLINE_SECTIONS[item.key]);
            return;
          }
          showToast('Kein Link gesetzt: ' + item.key);
        });
        wrap.appendChild(btn);
      });
    }

    function buildMatrixGrid() {
      const grid = document.getElementById('menuGrid');
      if (!grid) return;
      grid.innerHTML = '';
      MATRIX_ITEMS.forEach(item => {
        if (item.type === 'link' && !MAP_URLS[item.key]) {
          return;
        }
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = item.label;
        btn.addEventListener('click', () => {
          if (item.type === 'map') {
            showInlineMap(item.label, item.key);
            return;
          }
          if (item.type === 'link') {
            openMap(item.label, item.key, { forceLink: true });
            return;
          }
          toggleSection(INLINE_SECTIONS[item.key]);
        });
        grid.appendChild(btn);
      });
    }

    let core4Today = 0.0;
    let startTime = Date.now();

    function initUptime() {
      if (window.__AOS_UPTIME_RUNNING) return;
      window.__AOS_UPTIME_RUNNING = true;
      startTime = Date.now();
      updateUptime();
      setInterval(updateUptime, 1000);
      loadCore4Progress();
    }

    function updateUptime() {
      const elapsed = Date.now() - startTime;
      const hours = Math.floor(elapsed / 3600000);
      const minutes = Math.floor((elapsed % 3600000) / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      const el = document.getElementById('uptime');
      if (!el) return;
      el.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function toggleTheme() {
      document.body.classList.toggle('dark');
      const icon = document.getElementById('theme-icon');
      icon.textContent = document.body.classList.contains('dark') ? '‚òÄÔ∏è' : 'üåô';
    }

    function logCore4(domain, task) {
      const normalized = normalizeCore4Task(domain, task);
      if (!normalized) {
        showToast('Core4: domain/task fehlt.');
        return;
      }
      const d = normalized.domain;
      const t = normalized.task;

      core4Today += 0.5;
      document.getElementById('core4-today').textContent = `${core4Today.toFixed(1)}/4.0`;

      showToast(`Core4 logged: ${d} > ${t} (+0.5 points)`);
      addToTerminal(`core4 ${d} ${t}`, `‚úì Core4 logged: ${d} > ${t} (+0.5 points)`);

      try {
        const user = getWebUser();
        google.script.run
          .withFailureHandler(() => {})
          .core4_log(d, t, null, 'webapp', user);
      } catch (_) {}
    }

    function loadCore4Progress() {
      try {
        google.script.run
          .withSuccessHandler(data => {
            core4Today = (data && data.total) ? data.total : 0;
            document.getElementById('core4-today').textContent = `${core4Today.toFixed(1)}/4.0`;
          })
          .withFailureHandler(() => {})
          .core4_getToday();
      } catch (_) {}
    }

    function promoteToWarStack(taskId) {
      showToast('Task promoted to War Stack phase!');
      addToTerminal(`promote-warstack ${taskId}`, `‚úì Task promoted to War Stack: ${taskId}`);
      event.target.style.opacity = '0.5';
      event.target.textContent += ' ‚Üí War Stack';
    }

    function handleTerminalEnter(event) {
      if (event.key === 'Enter') {
        executeCommand();
      }
    }

    function executeCommand() {
      const input = document.getElementById('terminal-input');
      const command = input.value.trim();

      if (command) {
        let response = processCommand(command);
        addToTerminal(command, response);
        input.value = '';
      }
    }

    function buildStatusLine() {
      const stats = window.AOS_STATS || {};
      const hot = stats.hotlist || 0;
      const war = stats.warstacks || 0;
      const hits = stats.hits || 0;
      const c4 = Number(core4Today || 0).toFixed(1);
      return `Œ±OS v2.0.1 - Systems online\nHot List: ${hot} | War Stacks: ${war} | Hits: ${hits} | Core4: ${c4}/4.0`;
    }

    function processCommand(command) {
      const [cmd, ...args] = command.split(' ');

      switch (cmd) {
        case 'debug':
          triggerDebug();
          return 'Triggering debugStatus()...';
        case 'systemstatus':
          triggerSystemStatus();
          return 'Loading system status...';
        case 'bridgecheck':
          triggerBridgeCheck();
          return 'Checking bridge health...';
        case 'hotlist':
          return `‚úì Hot List item created: "${args.join(' ')}"`;
        case 'core4':
          return handleCore4Command(args);
        case 'door':
        case 'door-centre':
        case 'doorcenter':
          openMap('The Door Centre', 'door_centre');
          return '‚úì Opening Door Centre...';
        case 'voice':
          openMap('THE VOICE', 'voice');
          return '‚úì Opening Voice Centre...';
        case 'game':
          openMap('THE GAME', 'game');
          return '‚úì Opening Game Centre...';
        case 'frame':
          openMap('FRAME MAP', 'frame');
          return '‚úì Opening Frame Map...';
        case 'freedom':
          openMap('Freedom MAPS', 'freedom');
          return '‚úì Opening Freedom Map...';
        case 'focus':
          openMap('Focus MAPS', 'focus');
          return '‚úì Opening Focus Map...';
        case 'fire':
          openMap('Fire MAPS', 'fire');
          return '‚úì Opening Fire Map...';
        case 'tent':
          openMap("General's Tent", 'tent');
          return '‚úì Opening General\'s Tent...';
        case 'sync':
          triggerTaskSync();
          return 'Running task sync...';
        case 'tasksync':
          triggerTaskSync();
          return 'Running task sync...';
        case 'status':
          return buildStatusLine();
        case 'stats':
          triggerStats();
          return 'Fetching stats...';
        case 'props':
          triggerProps();
          return 'Fetching Script Props...';
        case 'generals-tent':
          return '‚úì Opening weekly review in Obsidian...';
        case 'door-war':
          return '‚úì Door War evaluation started...';
        case 'help':
          return 'Available commands: hotlist, core4, sync, tasksync, status, systemstatus, bridgecheck, stats, props, debug, door, voice, game, frame, freedom, focus, fire, tent, help';
        default:
          return `Command not found: ${cmd}. Type \'help\' for available commands.`;
      }
    }

    function normalizeCore4Task(domain, task) {
      if (!domain) return null;
      const d = String(domain || '').toLowerCase();
      const t = String(task || '').toLowerCase();

      const alias = {
        fitness: ['body', 'fitness'],
        fuel: ['body', 'fuel'],
        meditation: ['being', 'meditation'],
        memoirs: ['being', 'memoirs'],
        partner: ['balance', 'person1'],
        posterity: ['balance', 'person2'],
        person1: ['balance', 'person1'],
        person2: ['balance', 'person2'],
        discover: ['business', 'discover'],
        declare: ['business', 'declare']
      };

      if (!t && alias[d]) {
        return { domain: alias[d][0], task: alias[d][1] };
      }

      if (!t) return null;

      if (d === 'balance' && t === 'partner') return { domain: 'balance', task: 'person1' };
      if (d === 'balance' && t === 'posterity') return { domain: 'balance', task: 'person2' };

      return { domain: d, task: t };
    }

    function handleCore4Command(args) {
      if (!args.length) {
        return 'Usage: core4 <domain> <task> (z.B. core4 body fitness) oder core4 fitness/fuel/meditation/memoirs/partner/posterity/discover/declare';
      }
      const normalized = normalizeCore4Task(args[0], args[1]);
      if (!normalized) {
        return 'Core4: missing task. Example: core4 body fitness';
      }
      logCore4(normalized.domain, normalized.task);
      return `‚úì Core4 logged: ${normalized.domain} > ${normalized.task} (+0.5 points)`;
    }

    function addToTerminal(command, response) {
      const output = document.getElementById('terminal-output');
      const commandLine = document.createElement('div');
      commandLine.innerHTML = `<div>user@arch-laptop:~$ <span class="text-terminal-amber">${command}</span></div>`;

      const responseLine = document.createElement('div');
      responseLine.className = 'text-green-300';
      responseLine.textContent = response;

      const newPrompt = document.createElement('div');
      newPrompt.innerHTML = 'user@arch-laptop:~$ <span class="cursor-blink">|</span>';

      const oldCursor = output.querySelector('.cursor-blink');
      if (oldCursor) oldCursor.parentElement.remove();

      output.appendChild(commandLine);
      output.appendChild(responseLine);
      output.appendChild(document.createElement('div'));
      output.appendChild(newPrompt);

      output.scrollTop = output.scrollHeight;
    }

    function triggerDebug() {
      if (!(window.google && google.script && google.script.run)) {
        addToTerminal('debug', 'google.script not available');
        return;
      }
      google.script.run
        .withSuccessHandler(res => {
          addToTerminal('debug', 'debugStatus() logged to GAS console');
        })
        .withFailureHandler(err => {
          addToTerminal('debug', 'debugStatus failed: ' + err);
        })
        .debugStatus();
    }

    function triggerBridgeCheck() {
      if (!(window.google && google.script && google.script.run)) {
        addToTerminal('bridgecheck', 'google.script not available');
        return;
      }
      google.script.run
        .withSuccessHandler(res => {
          const ok = res && res.ok;
          const label = res && res.label ? res.label : 'unknown';
          const url = res && res.url ? res.url : 'n/a';
          addToTerminal('bridgecheck', (ok ? 'OK ' : 'FAIL ') + label + ' @ ' + url);
        })
        .withFailureHandler(err => {
          addToTerminal('bridgecheck', 'bridgecheck failed: ' + err);
        })
        .terminal_bridgecheck();
    }

    function triggerTaskSync() {
      if (!(window.google && google.script && google.script.run)) {
        addToTerminal('sync', 'google.script not available');
        return;
      }
      google.script.run
        .withSuccessHandler(res => {
          const stats = res || {};
          const created = stats.created || {};
          const updated = stats.updated || {};
          const lines = [
            `Created in TickTick: ${created.ticktick || 0}`,
            `Created in Taskwarrior: ${created.taskwarrior || 0}`,
            `Updated: ${(updated.ticktick || 0) + (updated.taskwarrior || 0)}`,
            `Errors: ${stats.errors || 0}`
          ];
          addToTerminal('sync', lines.join('\n'));
        })
        .withFailureHandler(err => {
          addToTerminal('sync', 'sync failed: ' + err);
        })
        .terminal_tasksync();
    }

    function triggerSystemStatus() {
      if (!(window.google && google.script && google.script.run)) {
        addToTerminal('systemstatus', 'google.script not available');
        return;
      }
      google.script.run
        .withSuccessHandler(res => {
          const bridge = res && res.bridge;
          const router = res && res.router;
          const heartbeat = res && res.heartbeat;
          const server = res && res.server;
          const lines = [
            `GAS: Online`,
            `Bridge: ${formatStatusLine(bridge)}`,
            `Router: ${formatStatusLine(router)}`,
            `Heartbeat: ${formatStatusLine(heartbeat)}`,
            `Server: ${server && server.locale ? server.locale : '‚Äî'}`
          ];
          addToTerminal('systemstatus', lines.join('\n'));
        })
        .withFailureHandler(err => {
          addToTerminal('systemstatus', 'systemstatus failed: ' + err);
        })
        .terminal_systemstatus();
    }

    function triggerStats() {
      if (!(window.google && google.script && google.script.run)) {
        addToTerminal('stats', 'google.script not available');
        return;
      }
      google.script.run
        .withSuccessHandler(res => {
          addToTerminal('stats', JSON.stringify(res, null, 2));
        })
        .withFailureHandler(err => {
          addToTerminal('stats', 'stats failed: ' + err);
        })
        .terminal_stats();
    }

    function triggerProps() {
      if (!(window.google && google.script && google.script.run)) {
        addToTerminal('props', 'google.script not available');
        return;
      }
      google.script.run
        .withSuccessHandler(res => {
          addToTerminal('props', JSON.stringify(res, null, 2));
        })
        .withFailureHandler(err => {
          addToTerminal('props', 'props failed: ' + err);
        })
        .terminal_props();
    }

    function aosTerminalLog(command, message, level) {
      const output = document.getElementById('terminal-output');
      if (!output) return;
      const cmd = String(command || 'system');
      const msg = String(message || '').trim();
      if (!msg) return;

      const commandLine = document.createElement('div');
      commandLine.innerHTML = `<div>user@arch-laptop:~$ <span class="text-terminal-amber">${cmd}</span></div>`;

      const responseLine = document.createElement('div');
      responseLine.className = level === 'warn' ? 'text-yellow-300' : 'text-green-300';
      responseLine.textContent = msg;

      const newPrompt = document.createElement('div');
      newPrompt.innerHTML = 'user@arch-laptop:~$ <span class="cursor-blink">|</span>';

      const oldCursor = output.querySelector('.cursor-blink');
      if (oldCursor) oldCursor.parentElement.remove();

      output.appendChild(commandLine);
      output.appendChild(responseLine);
      output.appendChild(document.createElement('div'));
      output.appendChild(newPrompt);

      output.scrollTop = output.scrollHeight;
    }

    window.aosTerminalLog = aosTerminalLog;

    function openGeneralsTent() {
      openMap('TENT', 'tent');
      addToTerminal('generals-tent', '‚úì Opened General\'s Tent');
    }

    function triggerSync() {
      triggerTaskSync();
    }

    function showNotifications() {
      openMap('VOICE', 'voice');
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      const toastMessage = document.getElementById('toast-message');

      toastMessage.textContent = message;
      toast.classList.remove('translate-x-full');

      setTimeout(() => {
        toast.classList.add('translate-x-full');
      }, 3000);
    }

    document.addEventListener('keydown', function(event) {
      if (event.ctrlKey && event.key === 'h') {
        event.preventDefault();
        document.getElementById('hotlist-input').focus();
      }

      if (event.ctrlKey && event.key === 't') {
        event.preventDefault();
        document.getElementById('terminal-input').focus();
      }

      if (event.ctrlKey && event.key === 'g') {
        event.preventDefault();
        openGeneralsTent();
      }
    });

    const style = document.createElement('style');
    style.textContent = `
      .cursor-blink { animation: blink 1s infinite; }
      @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
      }
    `;
    document.head.appendChild(style);
  </script>

  <script>
    const matrixCanvas = document.getElementById('matrix-rain');
    const matrixCtx = matrixCanvas ? matrixCanvas.getContext('2d') : null;
    const matrixChars = '„Ç¢„Ç´„Çµ„Çø„Éä„Éè„Éû„É§„É©„ÉØ„Ç¨„Ç∂„ÉÄ„Éê„Éë„Ç§„Ç≠„Ç∑„ÉÅ„Éã„Éí„Éü„É™„É≤„ÇÆ„Ç∏„ÉÇ„Éì„Éî„Ç¶„ÇØ„Çπ„ÉÑ„Éå„Éï„É†„É¶„É´„É≥„Ç¥„Çæ„Éâ„Éñ„Éù„Ç®„Ç±„Çª„ÉÜ„Éç„Éò„É°„É®„É¨„É≤„Ç≤„Çº„Éá„Éô„Éö„Ç™„Ç≥„ÇΩ„Éà„Éé„Éõ„É¢„É®„É≠„É≤„Ç¥„Çæ„Éâ„Éú„Éù0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const matrixFontSize = 14;
    let matrixColumns = 0;
    let matrixDrops = [];

    function resizeMatrix() {
      if (!matrixCanvas || !matrixCtx) return;
      matrixCanvas.width = window.innerWidth;
      matrixCanvas.height = window.innerHeight;
      matrixColumns = Math.floor(matrixCanvas.width / matrixFontSize);
      matrixDrops = new Array(matrixColumns).fill(1);
    }

    function drawMatrix() {
      if (!matrixCanvas || !matrixCtx) return;
      matrixCtx.fillStyle = 'rgba(0, 0, 0, 0.06)';
      matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
      matrixCtx.fillStyle = '#0f0';
      matrixCtx.font = `${matrixFontSize}px monospace`;

      for (let i = 0; i < matrixDrops.length; i += 1) {
        const text = matrixChars[Math.floor(Math.random() * matrixChars.length)];
        matrixCtx.fillText(text, i * matrixFontSize, matrixDrops[i] * matrixFontSize);
        if (matrixDrops[i] * matrixFontSize > matrixCanvas.height && Math.random() > 0.975) {
          matrixDrops[i] = 0;
        }
        matrixDrops[i] += 1;
      }
    }

    function initMatrixRain() {
      if (!matrixCanvas || !matrixCtx) return;
      resizeMatrix();
      window.addEventListener('resize', resizeMatrix);
      setInterval(drawMatrix, 35);
    }

    function bootMatrixDecor() {
      if (window.__AOS_MATRIX_BOOTED) return;
      window.__AOS_MATRIX_BOOTED = true;
      initMatrixRain();
      if (typeof buildMatrixGrid === 'function') {
        buildMatrixGrid();
      }
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(bootMatrixDecor, 0);
    } else {
      window.addEventListener('DOMContentLoaded', bootMatrixDecor);
    }
  </script>

  <script>
    function initTelegramWebApp() {
      if (typeof isTelegramWebApp === 'function' ? isTelegramWebApp() : false) {
        const tg = window.Telegram.WebApp;
        tg.expand();
        if (tg.MainButton) {
          tg.MainButton.text = 'Send to Œ±OS';
          tg.MainButton.show();
        }
        const params = tg.themeParams || {};
        document.body.style.backgroundColor = params.bg_color || '#1a1a1a';
        document.body.style.color = params.text_color || '#00ff00';

        if (typeof tg.onEvent === 'function') {
          tg.onEvent('mainButtonClicked', function() {
            const sessionData = {
              type: 'session_complete',
              core4_today: window.core4Today || 0,
              commands_executed: window.getExecutedCommands ? window.getExecutedCommands() : [],
              timestamp: new Date().toISOString()
            };
            window.Telegram.WebApp.sendData(JSON.stringify(sessionData));
            window.Telegram.WebApp.close();
          });
        }
      }
    }

    function isTelegramWebApp() {
      if (!window.Telegram || !window.Telegram.WebApp) return false;
      const tg = window.Telegram.WebApp;
      return Boolean(tg.initData) || Boolean(tg.initDataUnsafe && tg.initDataUnsafe.user);
    }

    function logCore4Telegram(domain, task) {
      if (isTelegramWebApp()) {
        const data = {
          type: 'core4',
          domain: domain,
          task: task,
          timestamp: new Date().toISOString(),
          source: 'telegram_webapp'
        };
        window.Telegram.WebApp.sendData(JSON.stringify(data));
        if (typeof showToast === 'function') {
          showToast(`Core4 logged: ${domain} > ${task}`);
        }
      } else if (typeof logCore4 === 'function') {
        logCore4(domain, task);
      }
    }

    function telegramHaptic(type) {
      if (!isTelegramWebApp()) return;
      if (!window.Telegram.WebApp.HapticFeedback) return;
      switch (type) {
        case 'light':
          window.Telegram.WebApp.HapticFeedback.impactOccurred('light');
          break;
        case 'medium':
          window.Telegram.WebApp.HapticFeedback.impactOccurred('medium');
          break;
        case 'heavy':
          window.Telegram.WebApp.HapticFeedback.impactOccurred('heavy');
          break;
        case 'success':
          window.Telegram.WebApp.HapticFeedback.notificationOccurred('success');
          break;
        case 'error':
          window.Telegram.WebApp.HapticFeedback.notificationOccurred('error');
          break;
        default:
          window.Telegram.WebApp.HapticFeedback.impactOccurred('light');
      }
    }

    const originalAddToHotList = window.addToHotList;
    const originalLogCore4 = window.logCore4;

    window.addToHotList = function() {
      telegramHaptic('light');
      if (isTelegramWebApp()) {
        addToHotListTelegram();
      } else if (typeof originalAddToHotList === 'function') {
        originalAddToHotList();
      }
    };

    window.logCore4 = function(domain, task) {
      telegramHaptic('success');
      if (isTelegramWebApp()) {
        logCore4Telegram(domain, task);
      } else if (typeof originalLogCore4 === 'function') {
        originalLogCore4(domain, task);
      }
    };

    function saveTelegramCloudStorage(key, data) {
      if (isTelegramWebApp() && window.Telegram.WebApp.CloudStorage) {
        window.Telegram.WebApp.CloudStorage.setItem(key, JSON.stringify(data));
      }
    }

    function loadTelegramCloudStorage(key) {
      if (isTelegramWebApp() && window.Telegram.WebApp.CloudStorage) {
        return new Promise(resolve => {
          window.Telegram.WebApp.CloudStorage.getItem(key, (error, data) => {
            if (!error && data) resolve(JSON.parse(data));
            else resolve(null);
          });
        });
      }
      return Promise.resolve(null);
    }

    function initTelegramStorage() {
      if (!isTelegramWebApp()) return;

      window.addEventListener('beforeunload', function() {
        saveTelegramCloudStorage('core4_progress', {
          today: window.core4Today || 0,
          date: new Date().toDateString()
        });
      });

      loadTelegramCloudStorage('core4_progress').then(progress => {
        if (progress && progress.date === new Date().toDateString()) {
          window.core4Today = progress.today || 0;
          const el = document.getElementById('core4-today');
          if (el) el.textContent = `${window.core4Today.toFixed(1)}/4.0`;
        }
      });
    }

    function getWebUser() {
      try {
        if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe) {
          const u = window.Telegram.WebApp.initDataUnsafe.user || {};
          return {
            id: u.id || 'web',
            username: u.username || '',
            first_name: u.first_name || 'Web'
          };
        }
      } catch (_) {}
      return { id: 'web', username: 'web', first_name: 'Web' };
    }

    function setupControlCenter() {
      try {
        initUptime();
        // Status first so UI isn‚Äôt blocked by later errors
        loadSystemStatus();
        setActiveMap('');
        initMatrixRain();
        initTelegramWebApp();
        initTelegramStorage();

        const backBtn = document.getElementById('mapsInlineBack');
        if (backBtn) {
          backBtn.addEventListener('click', () => {
            hideInlineMap();
            const target = document.querySelector('#mapsCentre .maps-container');
            target?.scrollIntoView({ behavior: 'smooth' });
            showHomeShell();
            showHeader();
          });
        }

        buildMatrixGrid();
        hydrateMapUrls(() => {
          buildCentreDots();
          buildMatrixGrid();
        });
        fruitsBoot();
        loadDashboardStats();
      } catch (err) {
        console.error('setupControlCenter error', err);
        setStatus('bridge-status', false, 'Error');
      }
    }

    function bootControlCenter() {
      if (window.__AOS_BOOTED) return;
      window.__AOS_BOOTED = true;
      setupControlCenter();
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(bootControlCenter, 0);
    } else {
      window.addEventListener('load', bootControlCenter);
    }
  </script>

  <script>
    const fruitsState = { data: null, answers: {} };

    function fruitsShowOverlay(on, title) {
      const overlay = document.getElementById('fruits-overlay');
      if (!overlay) return;
      if (title) {
        const t = overlay.querySelector('.loading-title');
        if (t) t.textContent = title;
      }
      overlay.classList.toggle('active', !!on);
    }

    function fruitsRandEmoji() {
      const e = (fruitsState.data && fruitsState.data.emojis) || [];
      return e.length ? e[Math.floor(Math.random() * e.length)] : 'üçé';
    }

    function fruitsBoot() {
      fruitsShowOverlay(true, 'Loading Facts...');
      google.script.run
        .withSuccessHandler(p => {
          fruitsState.data = p;
          fruitsState.answers = p.answers || {};
          fruitsRender();
          setTimeout(() => fruitsShowOverlay(false), 700);
        })
        .withFailureHandler(err => {
          console.error(err);
          alert('Fehler beim Laden der Facts');
          fruitsShowOverlay(false);
        })
        .fruits_getAllData();
    }

    function fruitsRender() {
      const data = fruitsState.data;
      if (!data) return;
      const allAnswers = fruitsState.answers || {};
      const pendingSkip = data.skipped && data.skipped.question;
      const container = document.getElementById('fruits-content');
      container.innerHTML = '';

      const title = document.getElementById('fruits-title');
      const subtitle = document.getElementById('fruits-subtitle');
      if (title && data.mapTitle) title.textContent = data.mapTitle;
      if (subtitle && data.mapSubtitle) subtitle.textContent = data.mapSubtitle;

      const sections = Object.keys(data.questions || {});
      let currentFound = false;
      let allDone = true;

      for (const section of sections) {
        const secDiv = document.createElement('div');
        secDiv.className = 'section';

        const header = document.createElement('div');
        header.className = 'section-header';
        header.innerHTML = `${fruitsRandEmoji()} <strong>${section}</strong> ${fruitsRandEmoji()}`;
        secDiv.appendChild(header);

        for (const q of data.questions[section] || []) {
          const qDiv = document.createElement('div');
          qDiv.className = 'question';

          if (allAnswers[q]) {
            if (allAnswers[q] === '_geskippt_') {
              allDone = false;
              qDiv.classList.add('skipped');
              qDiv.innerHTML = `<strong>${q}</strong><br><br><em>Geskippt - bitte spaeter beantworten.</em>`;

              const textarea = document.createElement('textarea');
              textarea.placeholder = 'Antwort nachholen...';
              textarea.rows = 6;
              qDiv.appendChild(textarea);

              const saveSkippedBtn = document.createElement('button');
              saveSkippedBtn.textContent = 'Geskippte Frage beantworten';
              saveSkippedBtn.onclick = () => {
                const ans = textarea.value.trim();
                if (!ans) {
                  alert('Bitte Antwort eingeben, um den Skip zu schliessen.');
                  return;
                }
                google.script.run
                  .withSuccessHandler(res => {
                    if (res && res.ok === false) {
                      alert(res.error || 'Speichern fehlgeschlagen.');
                      return;
                    }
                    fruitsBoot();
                  })
                  .fruits_saveAnswer(section, q, ans);
              };
              qDiv.appendChild(saveSkippedBtn);
            } else {
              qDiv.classList.add('answered');
              qDiv.innerHTML = `<strong>${q}</strong><br><br>${String(allAnswers[q]).replace(/\n/g, '<br>')}`;
            }
          } else {
            allDone = false;

            if (!currentFound) {
              currentFound = true;
              qDiv.innerHTML = `<strong class="active-question">${fruitsRandEmoji()} ${q} ${fruitsRandEmoji()}</strong>`;

              const textarea = document.createElement('textarea');
              textarea.placeholder = 'Raw & Honest Facts - no illusions...';
              textarea.rows = 10;
              qDiv.appendChild(textarea);

              const saveBtn = document.createElement('button');
              saveBtn.textContent = 'FACT - Save';
              saveBtn.onclick = () => {
                const ans = textarea.value.trim();
                if (!ans) {
                  alert('Keine Antwort - du kannst skippen oder ehrlich sein.');
                  return;
                }
                google.script.run
                  .withSuccessHandler(res => {
                    if (res && res.ok === false) {
                      alert(res.error || 'Speichern fehlgeschlagen.');
                      return;
                    }
                    fruitsBoot();
                  })
                  .fruits_saveAnswer(section, q, ans);
              };
              qDiv.appendChild(saveBtn);

              const skipBtn = document.createElement('button');
              skipBtn.textContent = 'Skip (spaeter nachholen)';
              skipBtn.style.background = '#666';
              skipBtn.style.marginLeft = '10px';
              if (pendingSkip) {
                skipBtn.disabled = true;
                skipBtn.title = 'Ein Skip ist noch offen - bitte zuerst beantworten.';
                skipBtn.style.opacity = '0.6';
                skipBtn.style.cursor = 'not-allowed';
              }
              skipBtn.onclick = () => {
                if (pendingSkip) {
                  alert('Du hast bereits eine Frage geskipped. Bitte beantworte sie zuerst.');
                  return;
                }
                if (confirm('Diese Frage ueberspringen? Du kannst spaeter zurueck.')) {
                  google.script.run
                    .withSuccessHandler(res => {
                      if (res && res.ok === false) {
                        alert(res.error || 'Skip fehlgeschlagen.');
                        return;
                      }
                      fruitsBoot();
                    })
                    .fruits_saveAnswer(section, q, '_geskippt_');
                }
              };
              qDiv.appendChild(skipBtn);
            } else {
              qDiv.innerHTML = `<em>${q}<br><small>(wird freigeschaltet, wenn alle vorherigen beantwortet sind)</small></em>`;
            }
          }

          secDiv.appendChild(qDiv);
        }
        container.appendChild(secDiv);
      }

      if (allDone || Object.keys(allAnswers).length > 0) {
        const exportBtn = document.getElementById('fruits-export');
        exportBtn.style.display = 'block';
        exportBtn.onclick = fruitsExportAll;
      }
    }

    function fruitsExportAll() {
      fruitsShowOverlay(true, 'Exportiere Map...');
      google.script.run
        .withSuccessHandler(res => {
          fruitsShowOverlay(false);
          alert(`Export gespeichert:\n${res.name}\n${res.url}`);
        })
        .withFailureHandler(err => {
          fruitsShowOverlay(false);
          console.error(err);
          alert('Export fehlgeschlagen.');
        })
        .fruits_exportCompleteMap();
    }
  </script>
