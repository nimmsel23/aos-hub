#!/usr/bin/env bash
set -euo pipefail

# syncctl
# A small, readable frontdoor for the various rclone helpers in this repo.
#
# Design goals:
# - predictable behavior (no "silent nothing happens")
# - safe defaults (dry-run and skip symlinks unless you turn it on)
# - minimal interactive UI logic (gum if available, otherwise simple numbered prompts)

APP="syncctl"

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd -P)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd -P)"

# Codex session helper: syncctl codex [purpose...]
# shellcheck disable=SC1091
source "$ROOT_DIR/scripts/lib/codex-subcmd.sh"
codex_subcmd_maybe "main" "syncctl" "$@" && exit 0

# Load global env (optional).
# shellcheck disable=SC1091
source "$SCRIPT_DIR/lib/aos-env.sh"
aos_env_load "" "$ROOT_DIR" || true

# Shared UI/helpers.
# shellcheck disable=SC1091
source "$SCRIPT_DIR/ctl-lib.sh"
CTL_APP_PREFIX="$APP"

AOS_SYNC="${SCRIPT_DIR}/aos-sync"
VAULTCTL_PRIMARY="${SCRIPT_DIR}/sync-utils/vaultctl"
VAULTCTL_FALLBACK="${SCRIPT_DIR}/utils/vaultctl"
DOMAIN_PRIMARY="${SCRIPT_DIR}/sync-utils/rclone-domain-sync.sh"
DOMAIN_FALLBACK="${SCRIPT_DIR}/utils/rclone-domain-sync.sh"
VITAL_PRIMARY="${SCRIPT_DIR}/sync-utils/rclone-vitaltrainer-copy.sh"
VITAL_FALLBACK="${SCRIPT_DIR}/utils/rclone-vitaltrainer-copy.sh"
FADARO_PRIMARY="${SCRIPT_DIR}/sync-utils/rclone-fadaro-push.sh"
HUB_LIVE_PRIMARY="${SCRIPT_DIR}/sync-utils/rclone-aos-hub-live-push.sh"
HUB_LIVE_FALLBACK="${SCRIPT_DIR}/utils/rclone-aos-hub-live-push.sh"

have_tty() { [[ -t 0 && -t 1 ]]; }
gum_tty_available() { has_gum && [[ -t 1 ]]; }

pick_bin() {
  local primary="$1"
  local fallback="$2"
  local name="$3"

  if [[ -n "$primary" && -x "$primary" ]]; then
    printf "%s\n" "$primary"
    return 0
  fi
  if [[ -n "$fallback" && -x "$fallback" ]]; then
    printf "%s\n" "$fallback"
    return 0
  fi
  if [[ -n "$name" ]] && has_cmd "$name"; then
    command -v "$name"
    return 0
  fi
  return 1
}

doctor_tty() {
  local in_tty="no" out_tty="no" err_tty="no"
  [[ -t 0 ]] && in_tty="yes"
  [[ -t 1 ]] && out_tty="yes"
  [[ -t 2 ]] && err_tty="yes"

  echo "syncctl doctor-tty"
  echo "  stdin tty : $in_tty"
  echo "  stdout tty: $out_tty"
  echo "  stderr tty: $err_tty"
  echo "  TERM      : ${TERM:-}"
  echo "  SSH_TTY   : ${SSH_TTY:-}"
  if [[ -e /dev/tty ]]; then
    if [[ -r /dev/tty && -w /dev/tty ]]; then
      echo "  /dev/tty  : readable+writable"
    else
      echo "  /dev/tty  : exists, but not readable/writable"
    fi
  else
    echo "  /dev/tty  : missing"
  fi
}

ensure_menu_tty() {
  if have_tty; then
    return 0
  fi
  if [[ -r /dev/tty && -w /dev/tty ]]; then
    exec </dev/tty >/dev/tty 2>/dev/tty
  fi
  have_tty
}

SYNCCTL_DRY_RUN="${AOS_DRY_RUN:-0}"
SYNCCTL_COPY_LINKS="${AOS_COPY_LINKS:-0}"
export AOS_COPY_LINKS="${SYNCCTL_COPY_LINKS}"

badge() {
  local run links
  [[ "${SYNCCTL_DRY_RUN}" == "1" ]] && run="DRY-RUN (no changes)" || run="RUN (makes changes)"
  [[ "${SYNCCTL_COPY_LINKS}" == "1" ]] && links="Symlinks: COPY contents" || links="Symlinks: SKIP"
  printf "%s | %s" "$run" "$links"
}

toggle_dry_run() {
  if [[ "${SYNCCTL_DRY_RUN}" == "1" ]]; then
    SYNCCTL_DRY_RUN=0
  else
    SYNCCTL_DRY_RUN=1
  fi
}

toggle_copy_links() {
  if [[ "${SYNCCTL_COPY_LINKS}" == "1" ]]; then
    SYNCCTL_COPY_LINKS=0
  else
    SYNCCTL_COPY_LINKS=1
  fi
  export AOS_COPY_LINKS="${SYNCCTL_COPY_LINKS}"
}

print_safety_notes() {
  cat <<'EOF'
Safety / mental model
---------------------

The two most common ways to lose data with rclone are:
1) pointing at the wrong remote path, especially the Drive root, and
2) using a destructive mode (sync/bisync) without a dry-run first.

Remote paths:
  - "eldanioo:" (no folder after the colon) means: Drive root.
    That is almost never what you want because it can pull your entire "Meine Ablage"
    into a local folder if you run a sync/bisync.
  - Use a specific folder path instead, for example: "eldanioo:business" or "eldanioo:Dokumente".
    A leading slash like "eldanioo:/business" is usually equivalent to "eldanioo:business".

Modes (roughly from safest to most dangerous):
  - copy push/pull: uploads/downloads new and changed files, but does not delete on the destination.
  - sync: mirrors one side into the other and can delete files on the destination.
  - bisync: two-way mirroring and can delete files on BOTH sides.

Symlinks:
  - Default here is to SKIP symlinks because they can point outside the folder.
  - If you enable link copying, rclone copies the link target contents (it does not preserve the symlink).

Dry-run:
  - Dry-run prints what would happen, but does not upload/download/delete anything.
  - If you are unsure, dry-run first.
EOF
}

usage() {
  cat <<'EOF'
syncctl — rclone sync frontdoor

This tool is intentionally small. Most of the real work happens in:
  - aos-sync (targets + timers)
  - vaultctl (copy push/pull)
  - rclone-domain-sync.sh (domain copy)
  - rclone-vitaltrainer-copy.sh (Vitaltrainer)

Common:
  syncctl menu
  syncctl safety
  syncctl doctor-tty

Targets (aos-sync):
  syncctl list
  syncctl status [<target>]   (no target = show all targets)
  syncctl run <target> [--dry] [--mode sync|bisync] [--resync]
  syncctl enable <target> [--at HH:MM]
  syncctl disable <target>
  syncctl logs <target> [--follow]
  syncctl doctor <target>

Vault copy (vaultctl):
  syncctl vault <status|sync|pull|sync-root|pull-root|sync-all|pull-all|sync-vitaltrainer|pull-vitaltrainer|logs|timers|watch> [args...]

Domains copy:
  syncctl domains <DOMAIN> <push|pull|push-sync|sync|status|log> [--dry-run]
  syncctl domains status-all

Vitaltrainer copy:
  syncctl vitaltrainer <push|pull|status> [--dry-run]

FADARO push:
  syncctl fadaro [--dry-run]

aos-hub live backup:
  syncctl hub <status|push> [--dry-run]
EOF
}

choose_plain() {
  local prompt="$1"
  shift
  local -a options=("$@")

  echo ""
  echo "$prompt"
  local i=1
  for opt in "${options[@]}"; do
    printf "  [%s] %s\n" "$i" "$opt"
    i=$((i + 1))
  done
  echo "  [q] Back/quit"
  printf "> "

  local reply
  IFS= read -r reply || return 1
  if [[ -z "$reply" || "$reply" =~ ^[qQ]$ ]]; then
    return 1
  fi
  if [[ "$reply" =~ ^[0-9]+$ ]] && (( reply >= 1 && reply <= ${#options[@]} )); then
    printf "%s" "${options[$((reply - 1))]}"
    return 0
  fi
  echo "Please enter a number from 1..${#options[@]}, or 'q'." >&2
  return 2
}

sync_choose() {
  local prompt="$1"
  shift
  local -a options=("$@")

  if gum_tty_available; then
    gum choose --header "$prompt" "${options[@]}"
    return $?
  fi

  while true; do
    local out=""
    if out="$(choose_plain "$prompt" "${options[@]}")"; then
      printf "%s" "$out"
      return 0
    fi
    local rc=$?
    if [[ "$rc" -eq 1 ]]; then
      return 1
    fi
  done
}

pause() {
  if gum_tty_available; then
    gum input --prompt "Press Enter to continue > " --value "" >/dev/null 2>&1 || true
  else
    read -r -p "Press Enter to continue..." _ || true
  fi
}

run_aos_sync() {
  local bin
  bin="$(pick_bin "$AOS_SYNC" "" "aos-sync")" || die "aos-sync not found"
  exec "$bin" "$@"
}

run_vault() {
  local bin
  bin="$(pick_bin "$VAULTCTL_PRIMARY" "$VAULTCTL_FALLBACK" "vaultctl")" || die "vaultctl not found"
  exec "$bin" "$@"
}

run_domains() {
  local bin
  bin="$(pick_bin "$DOMAIN_PRIMARY" "$DOMAIN_FALLBACK" "")" || die "rclone-domain-sync.sh not found"

  local sub="${1:-}"
  if [[ -z "$sub" || "$sub" == "status-all" ]]; then
    for d in BODY BEING BALANCE BUSINESS; do
      "$bin" "$d" status
    done
    exit 0
  fi

  local domain="$1"
  shift || true
  [[ -n "$domain" ]] || die "domains requires <DOMAIN>"
  exec "$bin" "$domain" "$@"
}

run_vitaltrainer() {
  local bin
  bin="$(pick_bin "$VITAL_PRIMARY" "$VITAL_FALLBACK" "")" || die "rclone-vitaltrainer-copy.sh not found"
  exec "$bin" "$@"
}

run_fadaro() {
  local bin
  bin="$(pick_bin "$FADARO_PRIMARY" "" "")" || die "rclone-fadaro-push.sh not found"
  exec "$bin" "$@"
}

run_hub_live() {
  local bin
  bin="$(pick_bin "$HUB_LIVE_PRIMARY" "$HUB_LIVE_FALLBACK" "")" || die "rclone-aos-hub-live-push.sh not found"
  exec "$bin" "$@"
}

menu_targets() {
  local bin
  bin="$(pick_bin "$AOS_SYNC" "" "aos-sync")" || die "aos-sync not found"

  local -a targets=()
  mapfile -t targets < <("$bin" list 2>/dev/null || true)
  if [[ "${#targets[@]}" -eq 0 ]]; then
    echo "I cannot find any configured targets right now." >&2
    echo "If you expected targets, check your sync.d/*.env files." >&2
    pause
    return 0
  fi

  while true; do
    echo ""
    echo "Current mode: $(badge)"
    local t
    t="$(sync_choose "Select a target. This lists configured target files; it does not run anything yet." "${targets[@]}")" || return 0

    while true; do
      echo ""
      echo "Target: $t"
      echo "Current mode: $(badge)"
      local a
      a="$(sync_choose "Choose what you want to do. If you are unsure, start with Status or Doctor." \
        "Status" \
        "Doctor (explain configuration)" \
        "Run (sync)" \
        "Run (bisync — can delete on both sides)" \
        "Enable timer" \
        "Disable timer" \
        "Logs" \
        "Back")" || break

      case "$a" in
        "Status") "$bin" status "$t" ;;
        "Doctor (explain configuration)") "$bin" doctor "$t" ;;
        "Run (sync)")
          if [[ "${SYNCCTL_DRY_RUN}" == "1" ]]; then
            "$bin" run "$t" --dry --mode sync
          else
            "$bin" run "$t" --mode sync
          fi
          ;;
        "Run (bisync — can delete on both sides)")
          if [[ "${SYNCCTL_DRY_RUN}" == "1" ]]; then
            "$bin" run "$t" --dry --mode bisync
          else
            "$bin" run "$t" --mode bisync
          fi
          ;;
        "Enable timer")
          echo ""
          echo "This creates/enables a systemd user timer for the target."
          echo "If you are unsure, do not enable timers until a dry-run looks correct."
          local at=""
          read -r -p "Enable at (HH:MM, empty=default): " at || true
          if [[ -n "$at" ]]; then
            "$bin" enable "$t" --at "$at"
          else
            "$bin" enable "$t"
          fi
          ;;
        "Disable timer") "$bin" disable "$t" ;;
        "Logs") "$bin" logs "$t" ;;
        "Back") break ;;
      esac
      pause
    done
  done
}

menu_vault() {
  while true; do
    echo ""
    echo "Current mode: $(badge)"
    local a
    a="$(sync_choose "Vault copy uses rclone copy (no deletes). If you are unsure, use dry-run first." \
      "Status" \
      "Push now (copy)" \
      "Pull now (copy)" \
      "Push all (root + sections)" \
      "Pull all (root + sections)" \
      "Logs" \
      "Timers" \
      "Back")" || return 0

    case "$a" in
      "Status") run_vault status ;;
      "Push now (copy)") run_vault sync $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run") ;;
      "Pull now (copy)") run_vault pull $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run") ;;
      "Push all (root + sections)") run_vault sync-all $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run") ;;
      "Pull all (root + sections)") run_vault pull-all $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run") ;;
      "Logs") run_vault logs ;;
      "Timers") run_vault timers ;;
      "Back") return 0 ;;
    esac
    pause
  done
}

menu_domains() {
  while true; do
    echo ""
    echo "Current mode: $(badge)"
    local domain
    domain="$(sync_choose "Select a domain. Domain copy is usually safe (copy push/pull). 'push-sync' is destructive." \
      "BODY" "BEING" "BALANCE" "BUSINESS" "Status all" "Back")" || return 0

    case "$domain" in
      "Back") return 0 ;;
      "Status all") run_domains status-all; pause; continue ;;
    esac

    while true; do
      echo ""
      echo "Domain: $domain"
      echo "Current mode: $(badge)"
      local a
      a="$(sync_choose "Choose an action. If you are unsure, start with Status and then a dry-run Push." \
        "Status" \
        "Push now (copy)" \
        "Pull now (copy)" \
        "Push-sync (delete remote files that are not present locally)" \
        "Log" \
        "Back")" || break

      case "$a" in
        "Status") run_domains "$domain" status ;;
        "Push now (copy)") run_domains "$domain" push $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run") ;;
        "Pull now (copy)") run_domains "$domain" pull $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run") ;;
        "Push-sync (delete remote files that are not present locally)") run_domains "$domain" push-sync $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run") ;;
        "Log") run_domains "$domain" log ;;
        "Back") break ;;
      esac
      pause
    done
  done
}

menu_vitaltrainer() {
  while true; do
    echo ""
    echo "Current mode: $(badge)"
    local a
    a="$(sync_choose "Vitaltrainer copy uses rclone copy. It does not delete on the destination." \
      "Status" \
      "Push now (copy)" \
      "Pull now (copy)" \
      "Back")" || return 0

    case "$a" in
      "Status") run_vitaltrainer status ;;
      "Push now (copy)") run_vitaltrainer push $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run") ;;
      "Pull now (copy)") run_vitaltrainer pull $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run") ;;
      "Back") return 0 ;;
    esac
    pause
  done
}

menu_fadaro() {
  while true; do
    echo ""
    echo "Current mode: $(badge)"
    local a
    a="$(sync_choose "This runs the FADARO push script. If you are unsure, start with dry-run." \
      "Push now" \
      "Back")" || return 0

    case "$a" in
      "Push now") run_fadaro $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run") ;;
      "Back") return 0 ;;
    esac
    pause
  done
}

menu_hub_live() {
  while true; do
    echo ""
    echo "Current mode: $(badge)"
    local a
    a="$(sync_choose "aos-hub live backup uses rclone copy (push-only, no deletes)." \
      "Status" \
      "Push now (copy)" \
      "Push now (dry-run)" \
      "Back")" || return 0

    case "$a" in
      "Status") run_hub_live status ;;
      "Push now (copy)") run_hub_live push ;;
      "Push now (dry-run)") run_hub_live push --dry-run ;;
      "Back") return 0 ;;
    esac
    pause
  done
}

menu_settings() {
  while true; do
    echo ""
    echo "Current mode: $(badge)"
    local a
    a="$(sync_choose "Settings change only this menu session. They do not modify any config files." \
      "Toggle dry-run" \
      "Toggle symlink copying" \
      "Safety notes" \
      "Back")" || return 0

    case "$a" in
      "Toggle dry-run") toggle_dry_run ;;
      "Toggle symlink copying") toggle_copy_links ;;
      "Safety notes") print_safety_notes; pause ;;
      "Back") return 0 ;;
    esac
  done
}

run_menu() {
  if ! ensure_menu_tty; then
    echo "syncctl: I cannot open an interactive menu because no usable TTY was detected." >&2
    echo "syncctl: Please run it from a normal terminal (not from a launcher/pipe)." >&2
    echo "" >&2
    doctor_tty >&2
    exit 2
  fi

  echo ""
  echo "syncctl menu"
  echo "This menu is just a shortcut. It will still ask the underlying tools to do the real work."

  while true; do
    echo ""
    echo "Current mode: $(badge)"
    local a
    a="$(sync_choose "What do you want to work on?" \
      "Targets (timers + sync/bisync)" \
      "Vault copy (push/pull)" \
      "Domains copy" \
      "Vitaltrainer copy" \
      "FADARO push" \
      "aos-hub live backup" \
      "Settings" \
      "Safety notes" \
      "Quit")" || return 0

    case "$a" in
      "Targets (timers + sync/bisync)") menu_targets ;;
      "Vault copy (push/pull)") menu_vault ;;
      "Domains copy") menu_domains ;;
      "Vitaltrainer copy") menu_vitaltrainer ;;
      "FADARO push") menu_fadaro ;;
      "aos-hub live backup") menu_hub_live ;;
      "Settings") menu_settings ;;
      "Safety notes") print_safety_notes; pause ;;
      "Quit") return 0 ;;
    esac
  done
}

main() {
  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    ""|-h|--help|help) usage ;;
    menu|ui) run_menu ;;
    safety|notes) print_safety_notes ;;
    doctor-tty) doctor_tty ;;
    status)
      if [[ $# -eq 0 ]]; then
        local bin
        bin="$(pick_bin "$AOS_SYNC" "" "aos-sync")" || die "aos-sync not found"
        local -a targets=()
        mapfile -t targets < <("$bin" list 2>/dev/null || true)
        if [[ "${#targets[@]}" -eq 0 ]]; then
          echo "syncctl: no targets found"
          exit 0
        fi
        for t in "${targets[@]}"; do
          [[ -z "$t" ]] && continue
          "$bin" status "$t" || true
          echo ""
        done
        exit 0
      fi
      run_aos_sync status "$@"
      ;;
    list|run|enable|disable|logs|doctor)
      run_aos_sync "$cmd" "$@"
      ;;
    vault) run_vault "$@" ;;
    domains|domain) run_domains "$@" ;;
    vitaltrainer|vital) run_vitaltrainer "$@" ;;
    fadaro) run_fadaro "$@" ;;
    hub|aos-hub) run_hub_live "$@" ;;
    *)
      usage
      die "unknown command: $cmd"
      ;;
  esac
}

main "$@"
