#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Load global env (optional).
# shellcheck disable=SC1091
source "$ROOT_DIR/scripts/lib/aos-env.sh"
aos_env_load "" "$ROOT_DIR" || true

VAULT_ROOT="${AOS_VAULT_ROOT:-${AOS_RCLONE_LOCAL:-${AOS_VAULT_DIR:-$HOME/AlphaOS-Vault}}}"
if command -v realpath >/dev/null 2>&1; then
  VAULT_ROOT="$(realpath -m -- "$VAULT_ROOT")"
elif command -v readlink >/dev/null 2>&1; then
  VAULT_ROOT="$(readlink -f -- "$VAULT_ROOT" 2>/dev/null || echo "$VAULT_ROOT")"
fi
LOG_DIR="${AOS_LOG_DIR:-$HOME/.local/share/alphaos/logs}"
LOG_FILE="${AOS_VAULT_LOG_FILE:-}"
if [ -z "${LOG_FILE}" ]; then
  if [ -f "$HOME/.dotfiles/logs/vaultctl-sync.log" ]; then
    LOG_FILE="$HOME/.dotfiles/logs/vaultctl-sync.log"
  else
    LOG_FILE="$LOG_DIR/vaultctl-sync.log"
  fi
fi
RCLONE_CONFIG="${AOS_RCLONE_CONFIG:-$HOME/.config/rclone/rclone.conf}"
RCLONE_BIN="${AOS_RCLONE_BIN:-$(command -v rclone || true)}"
SYSTEMCTL_BIN="${AOS_SYSTEMCTL_BIN:-$(command -v systemctl || true)}"
SLEEP_BETWEEN="${AOS_VAULT_SLEEP_BETWEEN:-30}"
COPY_LINKS_MODE="${AOS_VAULT_COPY_LINKS:-${AOS_COPY_LINKS:-1}}"
BACKUP_DIR_REMOTE="${AOS_VAULT_BACKUP_DIR_REMOTE:-${AOS_VAULT_BACKUP_DIR:-}}"
BACKUP_DIR_LOCAL="${AOS_VAULT_BACKUP_DIR_LOCAL:-}"
BACKUP_SUFFIX="${AOS_VAULT_BACKUP_SUFFIX:-}"

RCLONE_COMMON_OPTS=(--create-empty-src-dirs)
if [ "${COPY_LINKS_MODE}" = "1" ]; then
  RCLONE_COMMON_OPTS+=(--copy-links)
else
  RCLONE_COMMON_OPTS+=(--skip-links)
fi

LOCAL_PATHS=(
  "$VAULT_ROOT/Game"
  "$VAULT_ROOT/Door"
  "$VAULT_ROOT/Voice"
  "$VAULT_ROOT/Core4"
)

REMOTE_PATHS=(
  "${AOS_VAULT_REMOTE_GAME:-eldanioo:Alpha_Game}"
  "${AOS_VAULT_REMOTE_DOOR:-eldanioo:Alpha_Door}"
  "${AOS_VAULT_REMOTE_VOICE:-eldanioo:Alpha_Voice}"
  "${AOS_VAULT_REMOTE_CORE4:-eldanioo:Alpha_Core4}"
)

LABELS=(
  "Game"
  "Door"
  "Voice"
  "Core4"
)

have_tty() {
  [ -t 1 ]
}

have_gum() {
  command -v gum >/dev/null 2>&1
}

is_remote_root() {
  # Examples that mean "remote root":
  #   eldanioo:
  #   eldanioo:/
  local p="${1:-}"
  [[ "$p" =~ ^[^:]+:(/)?$ ]]
}

is_kebab_slug() {
  local s="${1:-}"
  [[ "$s" =~ ^[a-z0-9][a-z0-9-]*$ ]]
}

prompt() {
  local label="$1"
  local default="${2:-}"

  if have_gum && have_tty; then
    if [[ -n "$default" ]]; then
      gum input --prompt "$label: " --value "$default"
    else
      gum input --prompt "$label: "
    fi
    return 0
  fi

  if [[ -n "$default" ]]; then
    read -r -p "$label [$default]: " reply || return 1
    printf "%s" "${reply:-$default}"
  else
    read -r -p "$label: " reply || return 1
    printf "%s" "$reply"
  fi
}

confirm() {
  local label="$1"

  if have_gum && have_tty; then
    gum confirm "$label"
    return $?
  fi

  local reply=""
  read -r -p "$label [y/N]: " reply || return 1
  [[ "$reply" == "y" || "$reply" == "Y" ]]
}

scaffold_safe_push() {
  local name="${1:-}"
  local local_dir="${2:-}"
  local remote_dir="${3:-}"
  shift 3 || true

  local force=0
  local make_timer=0
  local at="00:00"
  local timer_flag_set=0
  local at_flag_set=0
  local interactive=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force) force=1 ;;
      --no-timer) make_timer=0; timer_flag_set=1 ;;
      --timer) make_timer=1; timer_flag_set=1 ;;
      --at)
        shift
        at="${1:-}"
        make_timer=1
        timer_flag_set=1
        at_flag_set=1
        ;;
      *)
        warn "unknown option: $1"
        return 2
        ;;
    esac
    shift || true
  done

  if [[ -z "$name" ]]; then
    interactive=1
    name="$(prompt "Script name (kebab-case, used in filenames)" "")"
  fi
  if ! is_kebab_slug "$name"; then
    warn "invalid name: '$name' (use kebab-case like 'dokumente' or 'vault-game')"
    return 2
  fi

  if [[ -z "$local_dir" ]]; then
    interactive=1
    local_dir="$(prompt "Local folder to push" "$VAULT_ROOT")"
  fi
  if [[ -z "$remote_dir" ]]; then
    interactive=1
    remote_dir="$(prompt "Remote folder (example: eldanioo:Dokumente)" "")"
  fi

  if [[ "$interactive" == "1" && "$timer_flag_set" == "0" ]]; then
    if confirm "Create a daily systemd user timer for this push?"; then
      make_timer=1
      if [[ "$at_flag_set" == "0" ]]; then
        at="$(prompt "Run daily at (HH:MM)" "$at")"
      fi
    else
      make_timer=0
    fi
  fi

  if [[ -z "$local_dir" || -z "$remote_dir" ]]; then
    warn "local and remote must not be empty"
    return 2
  fi
  if [[ ! "$remote_dir" =~ : ]]; then
    warn "remote must look like 'remote:folder' (got: $remote_dir)"
    return 2
  fi
  if is_remote_root "$remote_dir"; then
    warn "refusing remote root destination: '$remote_dir' (choose a folder like 'eldanioo:Dokumente')"
    return 2
  fi
  if [[ "$make_timer" == "1" ]]; then
    if [[ ! "$at" =~ ^([01]?[0-9]|2[0-3]):[0-5][0-9]$ ]]; then
      warn "invalid --at time: '$at' (expected HH:MM)"
      return 2
    fi
  fi

  local scripts_dir="$ROOT_DIR/scripts/sync-utils"
  local systemd_dir="$ROOT_DIR/systemd"
  local user_systemd_dir="$HOME/.config/systemd/user"

  local script_path="$scripts_dir/rclone-${name}-safe-push.sh"
  local service_path="$systemd_dir/vault-${name}-safe-push.service"
  local timer_path="$systemd_dir/vault-${name}-safe-push.timer"
  local service_link="$user_systemd_dir/$(basename "$service_path")"
  local timer_link="$user_systemd_dir/$(basename "$timer_path")"

  if [[ "$force" != "1" ]]; then
    if [[ -e "$script_path" || -e "$service_path" || -e "$service_link" ]]; then
      warn "one or more output files already exist; re-run with --force to overwrite"
      echo "  $script_path"
      echo "  $service_path"
      echo "  $service_link"
      if [[ "$make_timer" == "1" ]]; then
        echo "  $timer_path"
        echo "  $timer_link"
      fi
      return 2
    fi
    if [[ "$make_timer" == "1" && ( -e "$timer_path" || -e "$timer_link" ) ]]; then
      warn "timer output files already exist; re-run with --force to overwrite"
      echo "  $timer_path"
      echo "  $timer_link"
      return 2
    fi
  fi

  mkdir -p "$scripts_dir" "$systemd_dir" "$user_systemd_dir"

  # Normalize paths (best-effort). realpath -m is non-destructive and works even if the folder doesn't exist yet.
  if command -v realpath >/dev/null 2>&1; then
    local_dir="$(realpath -m -- "$local_dir")"
  fi

  info "Creating safe push script"
  cat >"$script_path" <<EOF
#!/usr/bin/env bash
set -euo pipefail

# Generated by: vaultctl scaffold-push
#
# This script uses rclone COPY (not sync). That means:
# - it uploads new/changed files
# - it does NOT delete files on the destination
#
# Symlinks:
# - default: skipped (AOS_COPY_LINKS=0)
# - if enabled: link target contents are copied (the symlink itself is not preserved)

NAME="${name}"
LOCAL_DIR="${local_dir}"
REMOTE_DIR="${remote_dir}"

RCLONE_CONFIG="\${AOS_RCLONE_CONFIG:-\$HOME/.config/rclone/rclone.conf}"
RCLONE_BIN="\${AOS_RCLONE_BIN:-\$(command -v rclone || true)}"

LOG_DIR="\${SYNCCTL_LOG_DIR:-\$HOME/.local/share/syncctl/logs}"
LOG_FILE="\$LOG_DIR/\${NAME}-safe-push.log"

is_remote_root() {
  local p="\${1:-}"
  [[ "\$p" =~ ^[^:]+:(/)?\$ ]]
}

usage() {
  cat <<'USAGE'
rclone-\${NAME}-safe-push.sh

Push LOCAL_DIR -> REMOTE_DIR using rclone copy (no deletes).

Options:
  --dry-run       Print what would happen, but do not transfer anything.
  --copy-links    Copy contents of symlink targets.
  --skip-links    Skip symlinks (default).
USAGE
}

DRY_RUN=0
COPY_LINKS_MODE="\${AOS_COPY_LINKS:-0}"

while [[ \$# -gt 0 ]]; do
  case "\$1" in
    -h|--help) usage; exit 0 ;;
    --dry-run) DRY_RUN=1 ;;
    --copy-links) COPY_LINKS_MODE=1 ;;
    --skip-links) COPY_LINKS_MODE=0 ;;
    *)
      echo "Unknown arg: \$1" >&2
      usage >&2
      exit 2
      ;;
  esac
  shift
done

if [[ -z "\$RCLONE_BIN" || ! -x "\$RCLONE_BIN" ]]; then
  echo "rclone not found in PATH" >&2
  exit 1
fi
if [[ ! -f "\$RCLONE_CONFIG" ]]; then
  echo "rclone config missing: \$RCLONE_CONFIG" >&2
  exit 1
fi
if [[ ! -d "\$LOCAL_DIR" ]]; then
  echo "local folder missing: \$LOCAL_DIR" >&2
  exit 1
fi
if is_remote_root "\$REMOTE_DIR"; then
  echo "refusing remote root destination: '\$REMOTE_DIR' (choose a folder like 'eldanioo:Dokumente')" >&2
  exit 2
fi

mkdir -p "\$LOG_DIR"

LINK_OPTS=(--skip-links)
if [[ "\$COPY_LINKS_MODE" == "1" ]]; then
  LINK_OPTS=(--copy-links)
fi

DRY_OPTS=()
if [[ "\$DRY_RUN" == "1" ]]; then
  DRY_OPTS+=(--dry-run)
fi

echo "[\$(date +%F\\ %T)] safe push: \$LOCAL_DIR -> \$REMOTE_DIR (dry-run=\$DRY_RUN, copy_links=\$COPY_LINKS_MODE)" >>"\$LOG_FILE"
if [[ -t 1 ]]; then
  "\$RCLONE_BIN" --config "\$RCLONE_CONFIG" copy --create-empty-src-dirs "\${LINK_OPTS[@]}" "\${DRY_OPTS[@]}" "\$LOCAL_DIR" "\$REMOTE_DIR" 2>&1 | tee -a "\$LOG_FILE"
else
  "\$RCLONE_BIN" --config "\$RCLONE_CONFIG" copy --create-empty-src-dirs "\${LINK_OPTS[@]}" "\${DRY_OPTS[@]}" "\$LOCAL_DIR" "\$REMOTE_DIR" >>"\$LOG_FILE" 2>&1
fi
EOF
  chmod +x "$script_path"

  info "Creating systemd user unit files"
  cat >"$service_path" <<EOF
[Unit]
Description=Vault safe push (${name})

[Service]
Type=oneshot
ExecStart=${script_path}
EOF

  if [[ "$make_timer" == "1" ]]; then
    cat >"$timer_path" <<EOF
[Unit]
Description=Vault safe push (${name}) (daily)

[Timer]
OnCalendar=*-*-* ${at}:00
Persistent=true

[Install]
WantedBy=timers.target
EOF

    ln -sf "$timer_path" "$timer_link"
  fi

  ln -sf "$service_path" "$service_link"

  echo ""
  info "Done."
  echo "Script:"
  echo "  $script_path"
  echo "Units:"
  echo "  $service_path"
  if [[ "$make_timer" == "1" ]]; then
    echo "  $timer_path"
  fi
  echo "Linked into:"
  echo "  $service_link"
  if [[ "$make_timer" == "1" ]]; then
    echo "  $timer_link"
  fi
  echo ""
  echo "Next steps:"
  echo "  1) Test (recommended):"
  echo "     $script_path --dry-run"
  if [[ "$make_timer" == "1" ]]; then
    echo "  2) Enable timer:"
    echo "     systemctl --user daemon-reload"
    echo "     systemctl --user enable --now $(basename "$timer_path")"
  else
    echo "  (No timer was created because you chose --no-timer.)"
  fi
}

info() {
  if have_gum && have_tty; then
    gum style --bold -- "$1"
  else
    echo "$1"
  fi
}

warn() {
  if have_gum && have_tty; then
    gum style --foreground 214 -- "$1"
  else
    echo "WARN: $1"
  fi
}

run_cmd() {
  local title="$1"
  shift

  if have_gum && have_tty; then
    gum spin --spinner dot --title "$title" -- "$@"
  else
    echo "$title"
    "$@"
  fi
}

wait_between() {
  if [ "${SLEEP_BETWEEN}" -le 0 ]; then
    return 0
  fi
  if have_tty; then
    info "waiting ${SLEEP_BETWEEN}s (press Enter to skip)"
    read -r -t "$SLEEP_BETWEEN" _ || true
  else
    info "waiting ${SLEEP_BETWEEN}s"
    sleep "$SLEEP_BETWEEN"
  fi
}

status() {
  info "vaultctl status"
  echo ""

  if [ -f "$RCLONE_CONFIG" ]; then
    info "rclone config: present"
  else
    warn "rclone config: missing"
  fi

  echo ""
  for i in "${!LOCAL_PATHS[@]}"; do
    if [ -d "${LOCAL_PATHS[$i]}" ]; then
      info "${LABELS[$i]}: ${LOCAL_PATHS[$i]} -> ${REMOTE_PATHS[$i]}"
    else
      warn "${LABELS[$i]}: missing (${LOCAL_PATHS[$i]})"
    fi
  done

  if [ -f "$LOG_FILE" ]; then
    echo ""
    info "last log lines ($LOG_FILE)"
    tail -n 10 "$LOG_FILE"
  fi
}

copy_direction() {
  local direction="$1"
  local dry_run="${2:-false}"

  mkdir -p "$LOG_DIR"

  if [ -z "$RCLONE_BIN" ] || [ ! -x "$RCLONE_BIN" ]; then
    warn "rclone not found in PATH"
    exit 1
  fi

  if [ ! -f "$RCLONE_CONFIG" ]; then
    warn "rclone config missing; nothing to do"
    exit 0
  fi

  if [ "$dry_run" = "true" ]; then
    info "vaultctl ${direction} (copy, dry-run)"
  else
    info "vaultctl ${direction} (copy)"
  fi
  echo ""

  for i in "${!LOCAL_PATHS[@]}"; do
    local_path="${LOCAL_PATHS[$i]}"
    remote_path="${REMOTE_PATHS[$i]}"
    label="${LABELS[$i]}"
    filter_from=()
    ignore_file="$local_path/.rcloneignore"
    if [ "$label" = "Core4" ]; then
      # Core4: sync only the append-only ledger (`.core4/**`).
      # Derived files like `core4_week_*.json` are rebuildable and should not be pushed to Drive,
      # otherwise Google Drive can create duplicate-name copies.
      filter_from=(--filter "+ .core4/**" --filter "- *")
    elif [ -f "$ignore_file" ]; then
      filter_from=(--filter-from "$ignore_file")
    fi
    backup_dir=""
    backup_opts=()
    if [ "$direction" = "push" ]; then
      backup_dir="$BACKUP_DIR_REMOTE"
    else
      backup_dir="$BACKUP_DIR_LOCAL"
    fi
    if [ -n "$backup_dir" ]; then
      backup_opts+=(--backup-dir "$backup_dir")
      if [ -n "$BACKUP_SUFFIX" ]; then
        backup_opts+=(--suffix "$BACKUP_SUFFIX")
      else
        backup_opts+=(--suffix ".bak-$(date +%Y%m%d-%H%M%S)")
      fi
    fi

    case "$direction" in
      push)
        if [ ! -d "$local_path" ]; then
          warn "skip $label; missing $local_path"
          continue
        fi
        if [ "$dry_run" = "true" ]; then
          run_cmd "copy $label -> $remote_path (dry-run)" "$RCLONE_BIN" --config "$RCLONE_CONFIG" copy "${RCLONE_COMMON_OPTS[@]}" "${backup_opts[@]}" "${filter_from[@]}" --dry-run "$local_path" "$remote_path"
        else
          run_cmd "copy $label -> $remote_path" "$RCLONE_BIN" --config "$RCLONE_CONFIG" copy "${RCLONE_COMMON_OPTS[@]}" "${backup_opts[@]}" "${filter_from[@]}" "$local_path" "$remote_path"
        fi
        ;;
      pull)
        mkdir -p "$local_path"
        if [ "$dry_run" = "true" ]; then
          run_cmd "copy $label <- $remote_path (dry-run)" "$RCLONE_BIN" --config "$RCLONE_CONFIG" copy "${RCLONE_COMMON_OPTS[@]}" "${backup_opts[@]}" "${filter_from[@]}" --dry-run "$remote_path" "$local_path"
        else
          run_cmd "copy $label <- $remote_path" "$RCLONE_BIN" --config "$RCLONE_CONFIG" copy "${RCLONE_COMMON_OPTS[@]}" "${backup_opts[@]}" "${filter_from[@]}" "$remote_path" "$local_path"
        fi
        ;;
      *)
        warn "Unknown direction: $direction"
        exit 1
        ;;
    esac

    if [ "$i" -lt $(( ${#LOCAL_PATHS[@]} - 1 )) ]; then
      wait_between
    fi
  done
}

sync() {
  copy_direction push "${1:-false}"
}

pull() {
  copy_direction pull "${1:-false}"
}

timers() {
  info "vaultctl timers"
  echo ""

  if [ -z "$SYSTEMCTL_BIN" ] || [ ! -x "$SYSTEMCTL_BIN" ]; then
    warn "systemctl not found"
    exit 1
  fi

  "$SYSTEMCTL_BIN" --user status alphaos-vault-sync.timer || true
  echo ""
  "$SYSTEMCTL_BIN" --user list-timers --all | rg -i "alphaos-vault-sync|vaultctl" || true
}

logs() {
  local lines="${1:-50}"

  if [ -f "$LOG_FILE" ]; then
    info "vaultctl logs ($LOG_FILE)"
    tail -n "$lines" "$LOG_FILE"
  else
    warn "log file missing: $LOG_FILE"
  fi
}

watch() {
  if have_gum && have_tty; then
    gum watch --interval 3s -- "vaultctl _render"
  else
    while true; do
      clear
      status
      sleep 3
    done
  fi
}

menu() {
  if ! have_gum || ! have_tty; then
    warn "menu requires gum and a TTY"
    return 1
  fi

  while true; do
    local choice
    choice="$(printf "%s\n" \
      "Status" \
      "Push now (copy)" \
      "Push dry-run (copy)" \
      "Pull now (copy)" \
      "Pull dry-run (copy)" \
      "Timers" \
      "Logs" \
      "Watch" \
      "Exit" \
      | gum choose --header "vaultctl menu")"

    case "$choice" in
      "Status") status ;;
      "Push now (copy)") sync ;;
      "Push dry-run (copy)") sync true ;;
      "Pull now (copy)") pull ;;
      "Pull dry-run (copy)") pull true ;;
      "Timers") timers ;;
      "Logs") logs ;;
      "Watch") watch ;;
      "Exit") break ;;
    esac
  done
}

render() {
  if ! have_gum || ! have_tty; then
    status
    return
  fi

  local rclone_status="missing"
  if [ -f "$RCLONE_CONFIG" ]; then
    rclone_status="present"
  fi

  local paths_block=""
  for i in "${!LOCAL_PATHS[@]}"; do
    if [ -d "${LOCAL_PATHS[$i]}" ]; then
      paths_block+="${LABELS[$i]}: ${LOCAL_PATHS[$i]} -> ${REMOTE_PATHS[$i]}\n"
    else
      paths_block+="${LABELS[$i]}: missing (${LOCAL_PATHS[$i]})\n"
    fi
  done

  local timers_block
  timers_block="$($SYSTEMCTL_BIN --user list-timers --all 2>/dev/null | rg -i "alphaos-vault-sync" || true)"

  local log_block="(no log)"
  if [ -f "$LOG_FILE" ]; then
    log_block="$(tail -n 10 "$LOG_FILE")"
  fi

  gum style --border normal --padding "0 1" --margin "1 0" --bold -- "vaultctl watch"
  gum style --border normal --padding "0 1" --margin "1 0" -- "rclone config: $rclone_status"
  gum style --border normal --padding "0 1" --margin "1 0" -- "$(printf "%b" "$paths_block")"

  if [ -n "$timers_block" ]; then
    gum style --border normal --padding "0 1" --margin "1 0" -- "timer:\n$timers_block"
  else
    gum style --border normal --padding "0 1" --margin "1 0" -- "timer: not found"
  fi

  gum style --border normal --padding "0 1" --margin "1 0" -- "log tail:\n$log_block"
}

case "${1:-sync}" in
  sync|"")
    if [ "${2:-}" = "--dry-run" ]; then
      sync true
    else
      sync
    fi
    ;;
  scaffold-push|scaffold_safe_push|new-push|make-push)
    # Usage:
    #   vaultctl scaffold-push <name> <local_dir> <remote_dir> [--at HH:MM] [--no-timer] [--force]
    scaffold_safe_push "${2:-}" "${3:-}" "${4:-}" "${@:5}"
    ;;
  pull)
    if [ "${2:-}" = "--dry-run" ]; then
      pull true
    else
      pull
    fi
    ;;
  status)
    status
    ;;
  watch)
    watch
    ;;
  menu)
    menu
    ;;
  timers)
    timers
    ;;
  logs)
    logs "${2:-50}"
    ;;
  _render)
    render
    ;;
  help|-h|--help)
    echo "vaultctl - Vault copy manager"
    echo ""
    echo "Usage:"
    echo "  vaultctl [command]"
    echo ""
    echo "Commands:"
    echo "  sync    Push local -> remote with rclone copy (default)"
    echo "  sync --dry-run  Dry-run push"
    echo "  pull    Pull remote -> local with rclone copy"
    echo "  pull --dry-run  Dry-run pull"
    echo "  status  Show paths and recent log lines"
    echo "  watch   Live status view"
    echo "  menu    Gum menu (interactive)"
    echo "  timers  Show alphaos-vault-sync timer status"
    echo "  logs    Show recent log lines (default: 50)"
    echo "  scaffold-push  Create a new safe 'rclone-*-safe-push.sh' + systemd timer"
    echo "  help    Show this help"
    ;;
  *)
    echo "Unknown command: $1"
    echo "Run 'vaultctl help' for usage."
    exit 1
    ;;
esac
