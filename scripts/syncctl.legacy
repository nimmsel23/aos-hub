#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd -P)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd -P)"

# Load global env (optional) so AOS_* defaults come from a single place.
# shellcheck disable=SC1091
source "$SCRIPT_DIR/lib/aos-env.sh"
aos_env_load "" "$ROOT_DIR" || true

AOS_SYNC="${SCRIPT_DIR}/aos-sync"
AOS_SYNCCTL="${SCRIPT_DIR}/aos-syncctl"
VAULTCTL_PRIMARY="${SCRIPT_DIR}/sync-utils/vaultctl"
VAULTCTL_FALLBACK="${SCRIPT_DIR}/utils/vaultctl"
DOMAIN_PRIMARY="${SCRIPT_DIR}/sync-utils/rclone-domain-sync.sh"
DOMAIN_FALLBACK="${SCRIPT_DIR}/utils/rclone-domain-sync.sh"
VITAL_PRIMARY="${SCRIPT_DIR}/sync-utils/rclone-vitaltrainer-copy.sh"
VITAL_FALLBACK="${SCRIPT_DIR}/utils/rclone-vitaltrainer-copy.sh"
FADARO_PRIMARY="${SCRIPT_DIR}/sync-utils/rclone-fadaro-push.sh"

have() { command -v "$1" >/dev/null 2>&1; }
have_tty() { [[ -t 0 && -t 1 ]]; }

SYNCCTL_DRY_RUN="${AOS_DRY_RUN:-0}"
SYNCCTL_COPY_LINKS="${AOS_COPY_LINKS:-0}"
export AOS_COPY_LINKS="${SYNCCTL_COPY_LINKS}"
UI_POINTER=">"
UI_HR_CHAR="-"

ui_is_utf8() {
  local loc="${LC_ALL:-${LC_CTYPE:-${LANG:-}}}"
  [[ "$loc" == *"UTF-8"* || "$loc" == *"utf8"* ]]
}

ui_has_color() {
  [[ -t 1 ]] || return 1
  [[ -z "${NO_COLOR:-}" ]] || return 1
  return 0
}

ui_init() {
  if ui_has_color; then
    UI_RESET=$'\033[0m'
    UI_BOLD=$'\033[1m'
    UI_DIM=$'\033[2m'
    UI_INV=$'\033[7m'
    UI_CYAN=$'\033[36m'
    UI_GREEN=$'\033[32m'
    UI_YELLOW=$'\033[33m'
  else
    UI_RESET=""
    UI_BOLD=""
    UI_DIM=""
    UI_INV=""
    UI_CYAN=""
    UI_GREEN=""
    UI_YELLOW=""
  fi

  if ui_is_utf8; then
    UI_POINTER="▸"
    UI_HR_CHAR="─"
  else
    UI_POINTER=">"
    UI_HR_CHAR="-"
  fi
}

ui_term_cols() {
  local cols="${COLUMNS:-}"
  if command -v tput >/dev/null 2>&1; then
    cols="$(tput cols 2>/dev/null || true)"
  fi
  if [[ -z "$cols" || ! "$cols" =~ ^[0-9]+$ || "$cols" -lt 40 ]]; then
    cols=80
  fi
  printf "%s" "$cols"
}

ui_clear() {
  if have_tty; then
    printf "\033[H\033[2J\033[3J"
  fi
}

ui_hr() {
  local cols
  cols="$(ui_term_cols)"
  local w=$((cols < 88 ? cols : 88))
  local line
  printf -v line "%*s" "$w" ""
  line="${line// /$UI_HR_CHAR}"
  printf "%s" "$line"
}

ui_mode_badge() {
  local run_label links_label
  [[ "${SYNCCTL_DRY_RUN}" == "1" ]] && run_label="DRY-RUN" || run_label="RUN"
  [[ "${SYNCCTL_COPY_LINKS}" == "1" ]] && links_label="LINKS:COPY" || links_label="LINKS:SKIP"

  if ! ui_has_color; then
    printf "%s | %s" "$run_label" "$links_label"
    return 0
  fi

  if [[ "${SYNCCTL_DRY_RUN}" == "1" ]]; then
    printf "\033[30;43m DRY-RUN \033[0m"
  else
    printf "\033[30;42m RUN \033[0m"
  fi

  if [[ "${SYNCCTL_COPY_LINKS}" == "1" ]]; then
    printf " \033[30;46m LINKS:COPY \033[0m"
  else
    printf " \033[30;47m LINKS:SKIP \033[0m"
  fi
}

ui_footer_hint() {
  local allow_dry="${1:-1}"
  if [[ "$allow_dry" == "1" ]]; then
    printf "%s↑/↓ select  Enter run  ←/→ (or d) dry-run  s links  q back%s\n" "$UI_DIM" "$UI_RESET"
  else
    printf "%s↑/↓ select  Enter run  q back%s\n" "$UI_DIM" "$UI_RESET"
  fi
}

ui_read_key() {
  local key rest
  if ! IFS= read -rsn1 key; then
    # Distinguish "no input possible" (EOF / no controlling tty) from "user canceled".
    return 2
  fi
  if [[ "$key" == $'\x1b' ]]; then
    IFS= read -rsn2 rest || true
    key+="$rest"
  fi
  printf "%s" "$key"
}

ui_toggle_dry_run() {
  if [[ "${SYNCCTL_DRY_RUN}" == "1" ]]; then
    SYNCCTL_DRY_RUN=0
  else
    SYNCCTL_DRY_RUN=1
  fi
}

ui_toggle_copy_links() {
  if [[ "${SYNCCTL_COPY_LINKS}" == "1" ]]; then
    SYNCCTL_COPY_LINKS=0
  else
    SYNCCTL_COPY_LINKS=1
  fi
  export AOS_COPY_LINKS="${SYNCCTL_COPY_LINKS}"
}

ui_choose() {
  local title="$1"
  local subtitle="$2"
  local allow_dry="${3:-1}"
  shift 3

  local -a items=("$@")
  local cursor=0

  while true; do
    ui_clear
    printf "%s%s%s  %s[%s]%s\n" "$UI_BOLD" "$title" "$UI_RESET" "$UI_DIM" "$(ui_mode_badge)" "$UI_RESET"
    if [[ -n "$subtitle" ]]; then
      printf "%s%s%s\n" "$UI_DIM" "$subtitle" "$UI_RESET"
    fi
    printf "%s%s%s\n\n" "$UI_DIM" "$(ui_hr)" "$UI_RESET"

    for i in "${!items[@]}"; do
      if [[ "$i" -eq "$cursor" ]]; then
        if ui_has_color; then
          printf "%s  %s %s%s\n" "$UI_INV" "$UI_POINTER" "${items[$i]}" "$UI_RESET"
        else
          printf "%s %s\n" "$UI_POINTER" "${items[$i]}"
        fi
      else
        printf "    %s\n" "${items[$i]}"
      fi
    done

    printf "\n"
    ui_footer_hint "$allow_dry"

    local key
    key="$(ui_read_key)"
    local rc=$?
    if [[ "$rc" -eq 2 ]]; then
      return 2
    fi
    [[ "$rc" -ne 0 ]] && return 1
    case "$key" in
      $'\x1b[A'|k) ((cursor > 0)) && cursor=$((cursor - 1)) ;;
      $'\x1b[B'|j) ((cursor < ${#items[@]} - 1)) && cursor=$((cursor + 1)) ;;
      $'\x1b[C'|l) [[ "$allow_dry" == "1" ]] && SYNCCTL_DRY_RUN=1 ;;
      $'\x1b[D'|h) [[ "$allow_dry" == "1" ]] && SYNCCTL_DRY_RUN=0 ;;
      d|D) [[ "$allow_dry" == "1" ]] && ui_toggle_dry_run ;;
      s|S) ui_toggle_copy_links ;;
      q|Q) return 1 ;;
      ""|$'\x0d')
        printf "%s" "${items[$cursor]}"
        return 0
        ;;
    esac
  done
}

pause_screen() {
  if have_tty; then
    read -r -p "Press Enter to continue..." _ || true
  fi
}

die() {
  echo "syncctl: $*" >&2
  exit 1
}

doctor_tty() {
  local in_tty="no" out_tty="no" err_tty="no"
  [[ -t 0 ]] && in_tty="yes"
  [[ -t 1 ]] && out_tty="yes"
  [[ -t 2 ]] && err_tty="yes"

  echo "syncctl doctor-tty"
  echo "  stdin tty : $in_tty"
  echo "  stdout tty: $out_tty"
  echo "  stderr tty: $err_tty"
  echo "  TERM      : ${TERM:-}"
  echo "  SSH_TTY   : ${SSH_TTY:-}"

  if [[ -e /dev/tty ]]; then
    if [[ -r /dev/tty && -w /dev/tty ]]; then
      echo "  /dev/tty  : readable+writable"
    else
      echo "  /dev/tty  : exists, but not readable/writable"
    fi
  else
    echo "  /dev/tty  : missing"
  fi
}

ensure_tty_for_menu() {
  if have_tty; then
    return 0
  fi

  if [[ -r /dev/tty && -w /dev/tty ]]; then
    # Some launchers/wrappers don't provide a controlling TTY on stdin/stdout.
    # Rebind stdio to /dev/tty so the interactive menu can still work.
    exec </dev/tty >/dev/tty 2>/dev/tty
  fi

  have_tty
}

pick_bin() {
  local primary="$1"
  local fallback="$2"
  local name="$3"
  if [[ -n "$primary" && -x "$primary" ]]; then
    echo "$primary"
    return 0
  fi
  if [[ -n "$fallback" && -x "$fallback" ]]; then
    echo "$fallback"
    return 0
  fi
  if [[ -n "$name" ]] && have "$name"; then
    command -v "$name"
    return 0
  fi
  return 1
}

usage() {
  cat <<'EOF'
syncctl — rclone sync control

Safety notes:
  - The safest default is one-way copy (push/pull). Copy does not delete files on the destination.
  - "sync", "push-sync" and especially "bisync" can delete files. Use dry-run first and only when you understand the direction.
  - A remote like "eldanioo:" (no path) means "Drive root". That is almost never what you want and can flood a local folder with your whole Drive.
  - Symlinks are skipped by default. If you enable link copying, the link target contents are copied (not the link itself).
  - Dry-run simulates changes and prints what would happen, without uploading/downloading/deleting anything.

Targets (aos-sync/aos-syncctl):
  syncctl menu
  syncctl list
  syncctl run <target> [--dry] [--mode sync|bisync] [--resync]
  syncctl enable <target> [--at HH:MM]
  syncctl disable <target>
  syncctl status <target>
  syncctl logs <target> [--follow]
  syncctl doctor <target>

Vault copy (vaultctl):
  syncctl vault <status|sync|pull|sync-root|pull-root|sync-all|pull-all|sync-vitaltrainer|pull-vitaltrainer|logs|timers|watch> [args...]

Domain copy (rclone-domain-sync.sh):
  syncctl domains <DOMAIN> <push|pull|push-sync|sync|status|log> [--dry-run]
  syncctl domains status-all

Vitaltrainer copy:
  syncctl vitaltrainer <push|pull|status> [--dry-run]

FADARO push:
  syncctl fadaro [--dry-run]

More help:
  syncctl safety
EOF
}

print_safety_notes() {
  cat <<'EOF'
Safety / mental model
---------------------

1) The remote path matters more than you think.
   If you configure a remote as "eldanioo:" (with no folder after the colon), you are pointing at the Drive root.
   In practice this means: a sync or bisync can pull your whole "Meine Ablage" into a local directory.
   Use a folder path instead, for example "eldanioo:BUSINESS" or "eldanioo:Dokumente".

2) Choose the least-destructive mode that still solves your problem.
   "copy push/pull" only uploads/downloads new and changed files. It does not delete files on the destination, which makes it much harder to destroy data.
   "sync" mirrors one side into the other. If a file exists only on the destination, sync may delete it.
   "bisync" is two-way mirroring. It can delete files on both sides, so one mistake can wipe local work or remote data.

3) Symlinks are special.
   By default this menu skips symlinks (LINKS:SKIP), because symlinks can point outside the folder and cause surprising uploads.
   If you enable link copying (LINKS:COPY), rclone copies the contents of the link target (it does not preserve the symlink).

4) Dry-run is your seatbelt.
   In this menu you can toggle dry-run with ←/→ or "d". When the badge says DRY-RUN, actions will print what would happen but will not transfer or delete anything.
   On the CLI you can pass --dry-run (some subcommands use --dry). If you are unsure, run with dry-run first.

Menu toggles
------------
This menu has two global toggles that affect actions started from the menu:
  - DRY-RUN / RUN: whether transfers are simulated or executed.
  - LINKS:SKIP / LINKS:COPY: whether symlinks are ignored or dereferenced and copied as file contents.

If you ever feel unsure: stop and run "syncctl safety" again, then use a dry-run.
EOF
}

run_targets() {
  local cmd="$1"; shift || true
  local bin
  bin="$(pick_bin "$AOS_SYNC" "" "aos-sync")" || die "aos-sync not found"
  if [[ "$cmd" == "status" && $# -eq 0 ]]; then
    local targets
    targets="$("$bin" list 2>/dev/null || true)"
    if [[ -z "$targets" ]]; then
      echo "syncctl: no targets found"
      exit 0
    fi
    while read -r t; do
      [[ -z "$t" ]] && continue
      "$bin" status "$t" || true
      echo ""
    done <<<"$targets"
    exit 0
  fi
  exec "$bin" "$cmd" "$@"
}

menu_targets_ui() {
  local bin
  bin="$(pick_bin "$AOS_SYNC" "" "aos-sync")" || die "aos-sync not found"

  local -a targets=()
  mapfile -t targets < <("$bin" list 2>/dev/null || true)
  if [[ "${#targets[@]}" -eq 0 ]]; then
    ui_clear
    echo "No targets found."
    pause_screen
    return 0
  fi

  while true; do
    local target
    target="$(ui_choose "Targets" "Select a target" 1 "${targets[@]}" "Back")"
    local rc=$?
    if [[ "$rc" -eq 2 ]]; then
      echo "syncctl: menu input failed (no usable TTY input)." >&2
      doctor_tty >&2
      return 2
    fi
    [[ "$rc" -ne 0 ]] && return 0
    [[ "$target" == "Back" ]] && return 0

    while true; do
      local action
      action="$(ui_choose "Target: $target" "Choose action" 1 \
        "Status" \
        "Run (sync)" \
        "Run (bisync)" \
        "Enable timer" \
        "Disable timer" \
        "Logs" \
        "Doctor" \
        "Back")"
      rc=$?
      if [[ "$rc" -eq 2 ]]; then
        echo "syncctl: menu input failed (no usable TTY input)." >&2
        doctor_tty >&2
        return 2
      fi
      [[ "$rc" -ne 0 ]] && break

      case "$action" in
        "Status") ("$bin" status "$target") ;;
        "Run (sync)")
          if [[ "${SYNCCTL_DRY_RUN}" == "1" ]]; then
            ("$bin" run "$target" --dry --mode sync)
          else
            ("$bin" run "$target" --mode sync)
          fi
          ;;
        "Run (bisync)")
          if [[ "${SYNCCTL_DRY_RUN}" == "1" ]]; then
            ("$bin" run "$target" --dry --mode bisync)
          else
            ("$bin" run "$target" --mode bisync)
          fi
          ;;
        "Enable timer")
          local at=""
          read -r -p "Enable at (HH:MM, empty=default): " at || true
          if [[ -n "$at" ]]; then
            ("$bin" enable "$target" --at "$at")
          else
            ("$bin" enable "$target")
          fi
          ;;
        "Disable timer") ("$bin" disable "$target") ;;
        "Logs") ("$bin" logs "$target") ;;
        "Doctor") ("$bin" doctor "$target") ;;
        "Back") break ;;
      esac
      pause_screen
    done
  done
}

menu_vault() {
  while true; do
    local choice
    choice="$(ui_choose "Vault copy" "copy push/pull (no deletes); toggle links with 's'" 1 \
      "Status" \
      "Push now (copy)" \
      "Pull now (copy)" \
      "Push vault root (copy)" \
      "Pull vault root (copy)" \
      "Push all (root + sections)" \
      "Pull all (root + sections)" \
      "Push Vitaltrainer (copy)" \
      "Pull Vitaltrainer (copy)" \
      "Logs" \
      "Timers" \
      "Watch" \
      "Back")"
    local rc=$?
    if [[ "$rc" -eq 2 ]]; then
      echo "syncctl: menu input failed (no usable TTY input)." >&2
      doctor_tty >&2
      return 2
    fi
    [[ "$rc" -ne 0 ]] && return 0

    case "$choice" in
      "Status") (run_vault status) ;;
      "Push now (copy)") (run_vault sync $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
      "Pull now (copy)") (run_vault pull $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
      "Push vault root (copy)") (run_vault sync-root $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
      "Pull vault root (copy)") (run_vault pull-root $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
      "Push all (root + sections)") (run_vault sync-all $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
      "Pull all (root + sections)") (run_vault pull-all $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
      "Push Vitaltrainer (copy)") (run_vault sync-vitaltrainer $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
      "Pull Vitaltrainer (copy)") (run_vault pull-vitaltrainer $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
      "Logs") (run_vault logs) ;;
      "Timers") (run_vault timers) ;;
      "Watch") (run_vault watch) ;;
      "Back") return 0 ;;
    esac
    pause_screen
  done
}

menu_domains() {
  while true; do
    local domain
    domain="$(ui_choose "Domains copy" "BODY / BEING / BALANCE / BUSINESS" 1 \
      "BODY" \
      "BEING" \
      "BALANCE" \
      "BUSINESS" \
      "Status all" \
      "Back")"
    local rc=$?
    if [[ "$rc" -eq 2 ]]; then
      echo "syncctl: menu input failed (no usable TTY input)." >&2
      doctor_tty >&2
      return 2
    fi
    [[ "$rc" -ne 0 ]] && return 0

    case "$domain" in
      "Back") return 0 ;;
      "Status all")
        (run_domains status-all)
        pause_screen
        continue
        ;;
    esac

    while true; do
      local action
      action="$(ui_choose "Domain: $domain" "copy push/pull; push-sync deletes remote; toggle links with 's'" 1 \
        "Status" \
        "Push now (copy)" \
        "Pull now (copy)" \
        "Push-sync (delete remote)" \
        "Log" \
        "Back")"
      rc=$?
      if [[ "$rc" -eq 2 ]]; then
        echo "syncctl: menu input failed (no usable TTY input)." >&2
        doctor_tty >&2
        return 2
      fi
      [[ "$rc" -ne 0 ]] && break

      case "$action" in
        "Status") (run_domains "$domain" status) ;;
        "Push now (copy)") (run_domains "$domain" push $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
        "Pull now (copy)") (run_domains "$domain" pull $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
        "Push-sync (delete remote)") (run_domains "$domain" push-sync $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
        "Log") (run_domains "$domain" log) ;;
        "Back") break ;;
      esac
      pause_screen
    done
  done
}

menu_vitaltrainer() {
  while true; do
    local choice
    choice="$(ui_choose "Vitaltrainer copy" "toggle links with 's'" 1 \
      "Status" \
      "Push now (copy)" \
      "Pull now (copy)" \
      "Back")"
    local rc=$?
    if [[ "$rc" -eq 2 ]]; then
      echo "syncctl: menu input failed (no usable TTY input)." >&2
      doctor_tty >&2
      return 2
    fi
    [[ "$rc" -ne 0 ]] && return 0

    case "$choice" in
      "Status") (run_vitaltrainer status) ;;
      "Push now (copy)") (run_vitaltrainer push $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
      "Pull now (copy)") (run_vitaltrainer pull $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
      "Back") return 0 ;;
    esac
    pause_screen
  done
}

menu_fadaro() {
  while true; do
    local choice
    choice="$(ui_choose "FADARO push" "toggle links with 's'" 1 \
      "Push now" \
      "Back")"
    local rc=$?
    if [[ "$rc" -eq 2 ]]; then
      echo "syncctl: menu input failed (no usable TTY input)." >&2
      doctor_tty >&2
      return 2
    fi
    [[ "$rc" -ne 0 ]] && return 0

    case "$choice" in
      "Push now") (run_fadaro $([[ "${SYNCCTL_DRY_RUN}" == "1" ]] && echo "--dry-run")) ;;
      "Back") return 0 ;;
    esac
    pause_screen
  done
}

run_menu() {
  if ! ensure_tty_for_menu; then
    echo "syncctl: interactive menu needs a TTY, but none was detected." >&2
    echo "syncctl: try running it from a normal terminal, not from a launcher/pipe." >&2
    echo "" >&2
    doctor_tty >&2
    echo "" >&2
    echo "Tip: you can still run non-interactive commands like:" >&2
    echo "  syncctl list" >&2
    echo "  syncctl status" >&2
    echo "  syncctl safety" >&2
    exit 2
  fi

  ui_init

  while true; do
    local choice
    choice="$(ui_choose "syncctl" "frontdoor (toggle dry-run + links globally)" 1 \
      "Targets" \
      "Vault copy" \
      "Domains copy" \
      "Vitaltrainer copy" \
      "FADARO push" \
      "Safety notes" \
      "Help" \
      "Quit")"
    local rc=$?
    if [[ "$rc" -eq 2 ]]; then
      echo "syncctl: menu input failed (no usable TTY input)." >&2
      doctor_tty >&2
      return 2
    fi
    [[ "$rc" -ne 0 ]] && return 0

    case "$choice" in
      "Targets") menu_targets_ui ;;
      "Vault copy") menu_vault ;;
      "Domains copy") menu_domains ;;
      "Vitaltrainer copy") menu_vitaltrainer ;;
      "FADARO push") menu_fadaro ;;
      "Safety notes") ui_clear; print_safety_notes; pause_screen ;;
      "Help") usage; pause_screen ;;
      "Quit") return 0 ;;
    esac
  done
}

run_vault() {
  local bin
  bin="$(pick_bin "$VAULTCTL_PRIMARY" "$VAULTCTL_FALLBACK" "vaultctl")" || die "vaultctl not found"
  exec "$bin" "$@"
}

run_domains() {
  local bin
  bin="$(pick_bin "$DOMAIN_PRIMARY" "$DOMAIN_FALLBACK" "")" || die "rclone-domain-sync.sh not found"

  local sub="${1:-}"
  if [[ -z "$sub" || "$sub" == "status-all" ]]; then
    for domain in BODY BEING BALANCE BUSINESS; do
      "$bin" "$domain" status
    done
    exit 0
  fi

  local domain="$1"; shift || true
  [[ -n "$domain" ]] || die "domains requires <DOMAIN>"
  exec "$bin" "$domain" "$@"
}

run_vitaltrainer() {
  local bin
  bin="$(pick_bin "$VITAL_PRIMARY" "$VITAL_FALLBACK" "")" || die "rclone-vitaltrainer-copy.sh not found"
  exec "$bin" "$@"
}

run_fadaro() {
  local bin
  bin="$(pick_bin "$FADARO_PRIMARY" "" "")" || die "rclone-fadaro-push.sh not found"
  exec "$bin" "$@"
}

main() {
  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    ""|-h|--help|help) usage ;;
    safety|notes) print_safety_notes ;;
    doctor-tty) doctor_tty ;;
    menu|ui) run_menu ;;
    list|run|enable|disable|status|logs|doctor) run_targets "$cmd" "$@" ;;
    vault) run_vault "$@" ;;
    domains|domain) run_domains "$@" ;;
    vitaltrainer|vital) run_vitaltrainer "$@" ;;
    fadaro) run_fadaro "$@" ;;
    *)
      usage
      die "unknown command: $cmd"
      ;;
  esac
}

main "$@"
